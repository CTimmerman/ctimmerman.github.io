<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Chess by Cees Timmerman, 2022-12-28</title>
	<link id="favicon" rel="icon" href="lib/rook.png">
	<style>
		/* Doesn't work in console.
		@font-face {
			font-family: 'TrueMonospace';
			src: url('fonts/GnuUnifontFull-Pm9P.ttf');
		}
		*/
		* {
			--bgcolor: brown;
			--fgcolor: yellow;
			color: var(--fgcolor);
			background-color: var(--bgcolor);
			border-color: var(--fgcolor);
			font-size: 10mm;
			line-height: 1em;
		}

		input[type=number] {
			font-size: medium;
			vertical-align: middle;
			width: 2em;
		}

		#alertcontainer {
			margin: 0;
			left: 0;
			top: 0;
			width: 100%;
			height: 100%;
			position: fixed;
			overflow: auto;
			display: flex;
			flex-wrap: wrap;
			align-items: center;
			/* vertical */
			justify-content: center;
			/* horizontal */
			visibility: hidden;
			background-color: rgba(0, 0, 0, 0.5);
		}

		.alert {
			/* margin: auto; */
			border: 1px solid var(--fgcolor);
			border-radius: 5px;
			box-shadow: 10px 10px 10px rgb(0 0 0 / 20%);
			padding: 1em;
			/* background-color: var(--bgcolor); */
			/* font-size: 200%; */
			text-align: center;
		}

		#boardtext {
			display: block;
			/*font-family: TrueMonospace;*/
			font-size: 0;
			/* Gets rid of newline spaces. */
			margin: 1em 0;
			position: relative;
			/* For relative position absolute children. */
			white-space: pre;
		}

		.w {
			background-color: lightgrey;
		}

		.b {
			background-color: darkgrey;
		}

		.wf {
			color: white;
		}

		.bf {
			color: black;
		}

		.square {
			height: 1em;
			width: 1em;
			display: inline-block;
			line-height: 1em;
			text-align: center;
			cursor: pointer;
		}

		.piece {
			background-color: transparent;
			height: 1em;
			line-height: 1em;
			width: 1em;
			text-align: center;
			display: block;
			pointer-events: none;
			position: absolute;
			transition: 0.4s;
		}

		.selected.w {
			background: radial-gradient(lightgray 30%, yellow);
		}

		.selected.b {
			background: radial-gradient(darkgray 30%, yellow);
		}

		.selected.w.nobg {
			background: lightgray;
		}

		.selected.b.nobg {
			background: darkgray;
		}

		label {
			font-size: 0.5em;
		}

		ol {
			list-style-position: inside;
		}
	</style>
</head>

<body>
	<div id="boardtext"></div>
	<input id="guides" type="checkbox" checked><label for="guides">Show potential moves</label>
	<label for="ai_level">AI level </label><input id="ai_level" type="number" value="1" min="1"
		onchange="say('Level ' + this.value)">
	<input id="black_ai_box" type="checkbox" checked><label for="black_ai_box">Black AI</label>
	<input id="white_ai_box" type="checkbox"><label for="white_ai_box">White AI</label>
	<input id="speak_black" type="checkbox" checked><label for="speak_black">Speak black moves</label>
	<input id="speak_white" type="checkbox"><label for="speak_white">Speak white moves</label>
	<div id="logtext"></div>
	<div id="alertcontainer" onclick="if(event.target===this)this.style.visibility='hidden'"></div>
	<script type="module">
		"use strict"
		const SAFARI = navigator.userAgent.indexOf('Safari') > -1
		const WINDOWS = navigator.userAgent.indexOf('Windows') > -1
		const COLORS = navigator.userAgent.indexOf('Chrome') > -1
		const MONOSPACE = !WINDOWS
		const WHITE = 0
		const BLACK = 1

		function clog(msg) {
			console.log("%c" + msg, "font-family: monospace; color: black; background-color: white")
		}

		class Piece {
			name = "Piece"
			char = "P"
			value = 0
			dirs = []
			moved = false
			constructor(x, y, color) {
				this.x = x
				this.y = y
				this.color = color ? color : WHITE
			}

			copy(piece) {
				if (!piece) piece = this
				const copy = new piece.constructor(this.x, this.y, this.color)
				copy.moved = this.moved
				return copy
			}

			get_moves(board, depth) {
				const grid = board.grid
				const moves = []
				for (let dir of this.dirs) {
					let tx = this.x + dir[0]
					let ty = this.y + dir[1]
					while (1) {
						let piece = board.xy2p([tx, ty])
						if (piece === ' ') moves.push([tx, ty])
						else if (piece && piece.color !== this.color) {
							moves.push([tx, ty])
							break
						}
						else break

						tx += dir[0]
						ty += dir[1]
					}
				}
				return moves
			}

			get_threats(board, depth) {
				const grid = board.grid
				const threats = []
				for (let row in grid) {
					for (let col in grid) {
						const piece = grid[row][col]
						if (piece == ' ' || piece.color === this.color) continue
						if (piece.get_moves(board, depth + 1).find(xy => xy[0] === this.x && xy[1] === this.y)) threats.push(piece)
					}
				}
				return threats
			}

			move(board, fr, do_log) {
				this.moved = true
				const ox = this.x
				const oy = this.y
				const capture = board.fr2p(fr)
				const move = this.char + xy2fr(ox, oy) + (capture === ' ' ? '' : 'x') + fr
				const xy = fr2xy(fr)
				board.grid[oy][ox] = ' '
				this.x = xy[0]
				this.y = xy[1]
				board.grid[this.y][this.x] = this
				if (do_log) {
					if (capture !== ' ') {
						board.captured.push(capture)
						say('Took ' + capture.name)
					}
					board.log_check(move, 1 - this.color)
				}
			}
		}

		class Rook extends Piece {
			name = "Rook"
			char = "R"
			value = 5
			dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]]
		}

		class Knight extends Piece {
			name = "Knight"
			char = "N"
			value = 3

			get_moves(board, depth) {
				let moves = []
				for (let dir of [[-2, -1], [-2, 1], [-1, -2], [1, -2], [2, -1], [2, 1], [1, 2], [-1, 2]]) {
					const tx = this.x + dir[0]
					const ty = this.y + dir[1]
					const piece = board.xy2p([tx, ty])
					if (piece === ' ' || (piece && piece.color !== this.color)) {
						moves.push([tx, ty])
					}
				}
				return moves
			}
		}

		class Bishop extends Piece {
			name = "Bishop"
			char = "B"
			value = 3
			dirs = [[-1, -1], [1, -1], [-1, 1], [1, 1]]
		}

		class Queen extends Piece {
			name = "Queen"
			char = "Q"
			value = 9
			dirs = [[-1, -1], [1, -1], [-1, 1], [1, 1], [1, 0], [-1, 0], [0, 1], [0, -1]]
		}

		class King extends Piece {
			name = "King"
			char = "K"
			value = 10  // Officially 0; playwise 3.5 to 4.

			get_moves(board, depth) {
				if (!depth) depth = 0
				if (depth > 1) return []
				const grid = board.grid
				const moves = []
				for (let dir of [[-1, -1], [1, -1], [-1, 1], [1, 1], [1, 0], [-1, 0], [0, 1], [0, -1]]) {
					let tx = this.x + dir[0]
					let ty = this.y + dir[1]
					let piece = board.xy2p([tx, ty])
					if (piece === ' ' || (piece && piece.color !== this.color)) {
						moves.push([tx, ty])
					}
				}
				// Castling.
				/* https://chessily.com/learn-chess/king/
				The king and rook have not yet been moved in the game.
				The king is not in check before and immediately after castling.
				The king will not move through a check during castling.
				All squares between the rook and king are empty.
				*/
				if (!this.moved && this.get_threats(board, depth).length === 0) {
					const rank = this.color ? 8 : 1
					let piece = board.fr2p('a' + rank)
					if (piece.char === 'R' && !piece.moved) {
						let clear = true
						for (let i = 1; i < this.x; ++i) {
							if (grid[8 - rank][i] !== ' ') clear = false
						}
						if (clear) moves.push([2, 8 - rank])
					}
					piece = board.fr2p('h' + rank)
					if (piece.char === 'R' && !piece.moved) {
						let clear = true
						for (let i = 6; i > this.x; --i) {
							if (grid[8 - rank][i] !== ' ') clear = false
						}
						if (clear) moves.push([6, 8 - rank])
					}
				}
				// Remove unsafe moves.
				let safe_moves = []
				for (let move of moves) {
					if (board.xy2p(move).char === "K") safe_moves.push(move)
					else {
						let new_board = board.copy()
						let new_piece = new_board.grid[this.y][this.x]
						let fr = xy2fr(...move)
						new_piece.move(new_board, fr)
						if (new_piece.get_threats(new_board, depth).length === 0) safe_moves.push(move)
					}
				}
				if (!this.moved) {
					// Can't castle over unsafe space.
					const frs = safe_moves.map(e => xy2fr(...e))
					for (let i = safe_moves.length - 1; i >= 0; --i) {
						let fr = xy2fr(...safe_moves[i])
						if (
							(fr === 'c8' && frs.indexOf('d8') < 0) ||
							(fr === 'g8' && frs.indexOf('f8') < 0) ||
							(fr === 'c1' && frs.indexOf('d1') < 0)
						) safe_moves.splice(i, 1)
					}
				}
				return safe_moves
			}

			move(board, fr, do_log) {
				super.move(board, fr, do_log)
				if (!do_log) return
				let move = board.log.pop()
				const y = this.y
				const rank = 8 - y
				if (move === `Ke${rank}g${rank}`) { // TODO? Only 5171 according to https://en.wikipedia.org/wiki/ICCF_numeric_notation
					move = '0-0'
					if (do_log) say("Castle.")
					board.grid[y][7].move(board, 'f' + rank)
				}
				if (move === `Ke${rank}c${rank}`) {
					move = '0-0-0'
					if (do_log) say("Castle.")
					board.grid[y][0].move(board, 'd' + rank)
				}
				board.log_check(move, 1 - this.color)
			}
		}

		class Pawn extends Piece {
			name = "Pawn"
			char = ""
			value = 1

			get_moves(board, depth) {
				const grid = board.grid
				const log = board.log
				const moves = []
				// Move straight.
				let dirs = this.color ? [[0, 1]] : [[0, -1]]
				for (let dir of dirs) {
					const tx = this.x + dir[0]
					const ty = this.y + dir[1]
					const piece = board.xy2p([tx, ty])
					if (piece === ' ') {
						moves.push([tx, ty])
						if (this.color && this.y === 1 && grid[ty + 1][tx] === ' ') moves.push([tx, ty + 1])
						if (!this.color && this.y === 6 && grid[ty - 1][tx] === ' ') moves.push([tx, ty - 1])
					}
				}
				// Capture diagonally.
				dirs = this.color ? [[-1, 1], [1, 1]] : [[-1, -1], [1, -1]]
				for (let dir of dirs) {
					const tx = this.x + dir[0]
					const ty = this.y + dir[1]
					const piece = board.xy2p([tx, ty])
					if ((piece && piece !== ' ' && piece.color !== this.color)) {
						moves.push([tx, ty])
					}
					// En passant.
					if ((this.color === BLACK && this.y === 4)
						|| (this.color === WHITE && this.y === 3)) {
						const double_jump = xy2fr(tx, this.color ? 6 : 1) + xy2fr(tx, this.color ? 4 : 3)
						if (log.slice(-1)[0] === double_jump) {
							moves.push([tx, ty])
						}
					}
				}
				return moves
			}

			move(board, fr, do_log) {
				super.move(board, fr, do_log)
				if (this.color === BLACK && this.y === 7
					|| this.color === WHITE && this.y === 0) {
					board.promote(fr, 'Q', this.color)
				}
				// En passant.
				if (this.color === BLACK && this.y != 5) return
				if (this.color === WHITE && this.y != 2) return
				const double_jump = xy2fr(this.x, this.color ? 6 : 1) + xy2fr(this.x, this.color ? 4 : 3)
				const log = board.log
				if (log.slice(-2)[0].slice(0, 4) === double_jump) {
					board.grid[this.y + (this.color ? -1 : 1)][this.x] = ' '
					log[log.length - 1] += ' e.p.'
					if (do_log) say("En passant.")
				}
			}
		}

		class Board {
			grid = [[], [], [], [], [], [], [], []]
			log = []
			captured = []

			reset() {
				this.log = []
				this.grid = [
					[new Rook(0, 0, BLACK), new Knight(1, 0, BLACK), new Bishop(2, 0, BLACK), new Queen(3, 0, BLACK), new King(4, 0, BLACK), new Bishop(5, 0, BLACK), new Knight(6, 0, BLACK), new Rook(7, 0, BLACK)],
					[new Pawn(0, 1, BLACK), new Pawn(1, 1, BLACK), new Pawn(2, 1, BLACK), new Pawn(3, 1, BLACK), new Pawn(4, 1, BLACK), new Pawn(5, 1, BLACK), new Pawn(6, 1, BLACK), new Pawn(7, 1, BLACK)],
					[' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],
					[' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],
					[' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],
					[' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],
					[new Pawn(0, 6), new Pawn(1, 6), new Pawn(2, 6), new Pawn(3, 6), new Pawn(4, 6), new Pawn(5, 6), new Pawn(6, 6), new Pawn(7, 6)],
					[new Rook(0, 7), new Knight(1, 7), new Bishop(2, 7), new Queen(3, 7), new King(4, 7), new Bishop(5, 7), new Knight(6, 7), new Rook(7, 7)],
				]
			}

			get_king(color) {
				for (let row in this.grid) {
					for (let col in this.grid) {
						const piece = this.grid[row][col]
						if (piece.char === "K" && piece.color === color) return piece
					}
				}
			}

			get_pieces(color) {
				const rv = []
				for (let row in this.grid) {
					for (let col in this.grid) {
						const piece = this.grid[row][col]
						if (piece.color === color) rv.push(piece)
					}
				}
				return rv
			}

			is_check(color) {
				const king = this.get_king(color)
				return !!king && king.get_threats(this).length > 0
			}

			is_mate(color) {
				if (!this.is_check(color)) return false
				const king = this.get_king(color)
				const saves = []
				for (let row in this.grid) {
					for (let col in this.grid) {
						let piece = this.grid[row][col]
						if (piece.color !== color) continue
						const moves = piece.get_moves(this)
						for (let move of moves) {
							const new_board = this.copy()
							const new_piece = new_board.grid[row][col]
							new_piece.move(new_board, xy2fr(...move))
							if (!new_board.is_check(color)) saves.push(new_piece.char + xy2fr(piece.x, piece.y) + xy2fr(...move))
						}
					}
				}
				return this.is_check(color) && king.get_moves(this).length === 0 && saves.length === 0
			}

			copy() {
				const new_board = new Board()
				new_board.log = [...this.log]
				new_board.captured = [...this.captured]
				for (let row in this.grid) {
					for (let col in this.grid) {
						const piece = this.grid[row][col]
						new_board.grid[row][col] = (piece === ' ') ? ' ' : piece.copy()
					}
				}
				return new_board
			}

			xy2p(xy) {
				if (xy[1] < 0 || xy[1] > 7 || xy[0] < 0 || xy[0] > 7) return ''
				return this.grid[xy[1]][xy[0]]
			}

			fr2p(fr) {
				const xy = fr2xy(fr)
				if (xy[0] >= 0 && xy[1] >= 0) return this.grid[xy[1]][xy[0]]
				return ''
			}

			log_check(move, color) {
				let c = this.is_check(color) ? (this.is_mate(color) ? '#' : '+') : ''
				if (c === '+') say('Check.')
				else if (c === '#') {
					c += color ? ' 1-0' : ' 0-1'; say('Checkmate. ' + ['Black', 'White'][color] + ' wins!')
					clearInterval(timer)
				}
				this.log.push(move + c)
			}

			promote(fr, kind, color) {
				const [x, y] = fr2xy(fr)
				switch (kind) {
					case 'Q':
						this.grid[y][x] = new Queen(x, y, color)
						break
					case 'B':
						this.grid[y][x] = new Bishop(x, y, color)
						break
					case 'N':
						this.grid[y][x] = new Knight(x, y, color)
						break
					case 'R':
						this.grid[y][x] = new Rook(x, y, color)
						break
				}
			}
		}


		function xy2fr(x, y) {
			return "abcdefgh"[x] + (8 - y)
		}

		function fr2xy(fr) {
			return ["abcdefgh".indexOf(fr[0]), 8 - parseInt(fr[1])]
		}

		const icons = {
			'0': '♙', '1': '♟︎',
			'R0': '♖', 'R1': '♜',
			'N0': '♘', 'N1': '♞',
			'B0': '♗', 'B1': '♝',
			'Q0': '♕', 'Q1': '♛',
			'K0': '♔', 'K1': '♚',
		}

		function render(board) {
			const grid = board.grid
			const log = board.log

			let files = `<span class="square">` + (` abcdefgh`.split('').join('</span><span class="square">')) + `</span>`
			let lines = [files + `<span id="clock1"></span>`]
			for (let row in grid) {
				let line = `<span class="square">${8 - row}</span>`
				for (let col in grid) {
					line += `<span id="${xy2fr(col, row)}" class="square ${'wb'[(row % 2 + col % 2) % 2]}">  </span>`
				}
				line += `<span class="square">${8 - row}</span>`
				lines.push(line)
			}
			lines.push(files + `<span id="clock0"></span>`)

			files = ' abcdefgh '
			let blank = ' '
			if (!MONOSPACE) {
				files = ' a b c d e f g h '
				blank = '  '
			}
			let text_lines = [files]
			for (let row in grid) {
				let text_line = COLORS ? `${8 - row}\x1B[30m` : `${8 - row}`
				for (let col in grid) {
					if (COLORS) text_line += ['\x1B[47m', '\x1B[100m'][(row % 2 + col % 2) % 2]
					const p = grid[row][col]
					if (p === ' ') {
						text_line += COLORS ? ' ' : ' .'[(row % 2 + col % 2) % 2]
						if (!MONOSPACE) text_line += ' '
						continue
					}
					text_line += icons[p.char + p.color]
					let html = ''
					if (p.color) html = `<span class="piece bf">${icons[p.char + '1']}</span>`
					else html = `<span class="piece wf">${icons[p.char + '1']}</span><span class="piece bf">${icons[p.char + '0']}</span>`
					lines.push(`<div id="p${xy2fr(col, row)}" class='piece' style='left: ${1 + parseInt(col)}em; top: ${1 + parseInt(row)}em'>${html}</div>`)
				}
				text_lines.push(text_line + (COLORS ? `\x1B[m${8 - row}` : `${8 - row}`))
			}
			text_lines.push(files)
			clog(text_lines.join('\n'))
			boardtext.innerHTML = lines.join('\n')

			let html = ''
			let txt = ''
			for (let i = 0; i < log.length; i += 2) {
				html += `<li>${log[i]} ${log[i + 1] || ''}</li>`
				txt += `${1 + i / 2}. ${log[i]} ${log[i + 1] || ''} `
			}
			logtext.innerHTML = `<ol>${html}</ol>`

			clog(board.captured.map(e => icons[e.char + e.color]).join(''))
			if (txt.length > 77) clog(`...${txt.slice(-77)}`)
			else clog(txt)

			show_clock()
			document.querySelectorAll('.square').forEach(el => {
				el.onmousedown = function (e) {
					e.preventDefault()  // Stop doubleclick select.
				}
				el.onmouseup = function (e) {
					if (this.classList.contains('selected')) {
						if (start_fr && start_fr !== this.id) {
							show_move(start_fr, this.id, true)
							start_fr = null
							return
						}
					}
					document.querySelectorAll('.selected').forEach(el => {
						el.classList.remove('selected')
						el.classList.remove('nobg')
					})
					const piece = board.fr2p(this.id)
					if (!piece || piece === ' ' || this.id === window.start_fr) {
						window.start_fr = null
						return
					}
					window.start_fr = this.id
					this.classList.add('selected')
					const moves = piece.get_moves(board)
					for (let move of moves) {
						let square = document.getElementById(xy2fr(...move))
						square.classList.add('selected')
						if (!guides.checked) square.classList.add('nobg')
					}
				}
			})
		}

		function random_choice(array) {
			return array[Math.floor(Math.random() * array.length)]
		}

		function prune_move(piece, move) {
			piece.moves = piece.moves.filter(m => m[0] !== move[0] || m[1] !== move[1])
		}

		async function ai_move(board_in, depth, color) {
			var start_time = performance.now()
			let my_board = board
			if (typeof board_in !== "undefined") my_board = board_in
			if (typeof depth === "undefined") depth = 0
			else if (depth > ai_level.value - 1) return
			if (typeof color === "undefined") color = 1 - my_board.log.length % 2
			let pieces = my_board.get_pieces(color)
			pieces.forEach(p => p.moves = p.get_moves(my_board))
			pieces = pieces.filter(p => p.moves.length > 0)
			let best_score = 9999
			let best_move = null
			let best_piece = null
			let max_think = 100
			if (depth > 1) max_think = 8
			for (let i = 0; i < max_think; ++i) {
				if (pieces.length < 1) break
				const piece = random_choice(pieces)
				const move = random_choice(piece.moves)
				// Eval move.
				const new_board = my_board.copy()
				const new_piece = new_board.grid[piece.y][piece.x]
				const capture = new_board.grid[move[1]][move[0]]
				new_piece.move(new_board, xy2fr(...move))
				if (new_board.is_check(color)) {
					prune_move(piece, move)
					pieces = pieces.filter(p => p.moves.length > 0)
					continue  // Keep own king safe.
				}
				// if (new_board.is_mate(1 - color)) {
				// 	best_move = move
				// 	best_piece = piece
				// 	break
				// }
				// Set response.
				await ai_move(new_board, depth + 1, 1 - color)
				const my_score = new_board.get_pieces(color).reduce((sum, el) => sum + el.value, 0)
				const enemy_score = new_board.get_pieces(1 - color).reduce((sum, el) => sum + el.value, 0)
				const score = enemy_score - my_score
				if (score > best_score) {
					prune_move(piece, move)
					pieces = pieces.filter(p => p.moves.length > 0)
				} else if (score < best_score) {
					best_score = score
					best_move = move
					best_piece = piece
				}
			}
			if (depth > 0) {
				if (best_piece) best_piece.move(my_board, xy2fr(...best_move))
			} else {
				if (best_piece) await show_move(xy2fr(best_piece.x, best_piece.y), xy2fr(...best_move))
				else {
					my_board.log.push('½–½')
					say('Draw.')
					clearInterval(timer)
					render()
				}
			}
			if (depth < 1) clog(`Level ${ai_level.value} max_think ${max_think} took ${ms2time(performance.now() - start_time)}`)
		}
		window.ai_move = ai_move
		const think_time = 2500

		import sleep from './lib/sleep.mjs'
		import say_it from './lib/say.mjs'
		window.say = function say(msg) {
			say_it(msg, WINDOWS ? 1.9 : 1, 1, "en-UK")
		}
		window.say = say

		async function show_move(start_fr, stop_fr, is_human) {
			favicon.href = 'lib/rook.png'
			const piece = board.fr2p(start_fr)
			const c = piece.char
			const color = piece.color

			if ((color === BLACK && speak_black.checked) ||
				(color === WHITE && speak_white.checked)) say(`${start_fr} ${stop_fr}`.toUpperCase())  // Even uppercase fails "a7 a5" on MacOS!

			const style = document.getElementById('p' + start_fr).style
			const [x, y] = fr2xy(stop_fr)
			style.left = (1 + x) + 'em'
			style.top = (1 + y) + 'em'

			piece.move(board, stop_fr, true)
			await sleep(400)
			render(board)
			await sleep(400)

			if (is_human && c === '' && (
				(color === BLACK && y === 7) ||
				(color === WHITE && y === 0))) {
				let html = `
					<button onclick="promote('${stop_fr}', 'Q', ${color})">♛</button>
					<button onclick="promote('${stop_fr}', 'B', ${color})">♝</button>
					<button onclick="promote('${stop_fr}', 'N', ${color})">♞</button>
					<button onclick="promote('${stop_fr}', 'R', ${color})">♜</button>
					`
				nonblocking_alert(html)
				while (getComputedStyle(alertcontainer).visibility === 'visible') await (sleep(1000))
			}

			if (board.log[board.log.length - 1].indexOf('#') > -1) return
			const max_moves = 75
			if (board.log.length > max_moves && !board.log.slice(-max_moves).some(s => s.indexOf('x') > -1 || s.match(/^[a-h]/) > -1)) {
				const msg = `${max_moves} moves without checkmate, capture, or pawn move. Draw.`
				clog(msg)
				say(msg)
				clearInterval(timer)
				return
			}
			start_clock(1 - color)
			if (color === WHITE && black_ai_box.checked) {
				favicon.href = 'lib/think.png'
				await sleep(think_time); ai_move(board, 0, BLACK)
			}
			if (color === BLACK && white_ai_box.checked) {
				favicon.href = 'lib/think.png'
				await sleep(think_time); ai_move(board, 0, WHITE)
			}
		}

		function promote(fr, kind, color) {
			alertcontainer.style.visibility = 'hidden'
			board.promote(fr, kind, color)
			say('Promote to ' + board.fr2p(fr).name)
			board.log_check(board.log.pop() + kind, 1 - color)
			render(board)
		}
		window.promote = promote

		function nonblocking_alert(html) {
			if (getComputedStyle(alertcontainer).visibility == 'hidden') {
				alertcontainer.innerText = ''
				alertcontainer.style.visibility = 'visible'
			}
			const d = document.createElement('div')
			d.className = 'alert'
			d.innerHTML = html
			alertcontainer.appendChild(d)
		}
		window.modal = nonblocking_alert

		window.timer = null
		const clock_start = [0, 0]
		const clock_running = [false, false]
		const clock_ms = [0, 0]
		function start_clock(color) {
			clock_start[color] = performance.now()
			clock_running[color] = true
			clock_running[1 - color] = false
			clock_ms[1 - color] += performance.now() - clock_start[1 - color]
			show_clock()
			clearInterval(timer)
			timer = setInterval(show_clock, 1000)
		}
		function show_clock() {
			for (let color of [0, 1]) {
				const el = document.getElementById('clock' + color)
				if (clock_running[color]) el.innerText = ms2time(clock_ms[color] + performance.now() - clock_start[color])
				else el.innerText = ms2time(clock_ms[color])
			}
		}
		window.show_clock = show_clock
		function ms2time(ms) {
			const secs = ms / 1000
			return ('0' + Math.floor(secs / 60)).slice(-2) + ':' + ('0' + Math.floor(secs % 60)).slice(-2)
		}
		window.ms2time = ms2time

		const board = new Board()
		board.reset()
		render(board)
		window.board = board
		start_clock(WHITE)
		if (white_ai_box.checked) ai_move(board, 0, WHITE)
	</script>
</body>

</html>