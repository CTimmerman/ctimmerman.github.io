<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Chess by Cees Timmerman, 2022-12-28</title>
	<style>
		* {
			--bgcolor: brown;
			--fgcolor: yellow;
			color: var(--fgcolor);
			background-color: var(--bgcolor);
			font-size: 10mm;
		}

		#alertcontainer {
			margin: 0;
			left: 0;
			top: 0;
			width: 100%;
			height: 100%;
			position: fixed;
			overflow: auto;
			display: flex;
			flex-wrap: wrap;
			align-items: center;
			/* vertical */
			justify-content: center;
			/* horizontal */
			visibility: hidden;
			background-color: rgba(0, 0, 0, 0.5);
		}

		.alert {
			margin: auto;
			border: 1px solid var(--fgcolor);
			border-radius: 5px;
			box-shadow: 10px 10px 10px rgb(0 0 0 / 20%);
			min-width: 10em;
			padding: 1em;
			background-color: var(--bgcolor);
			font-size: 200%;
			text-align: center;
		}

		#boardtext {
			display: block;
			font-family: monospace;
			font-size: 0; // Gets rid of newline spaces.
			margin: 1em 0;
			white-space: pre;
		}

		.w {
			background-color: lightgrey;
		}

		.b {
			background-color: darkgrey;
		}

		.wf {
			color: white;
		}

		.bf {
			color: black;
		}

		.square {
			height: 1em;
			width: 1em;
			display: inline-block;
			line-height: 1em;
			text-align: center;
			cursor: pointer;
		}

		.piece {
			background-color: transparent;
			position: relative;
		}

		.over {
			margin-left: -1em;
		}

		.selected.w {
			background: radial-gradient(lightgray 30%, yellow);
		}

		.selected.b {
			background: radial-gradient(darkgray 30%, yellow);
		}

		.selected.w.nobg {
			background: lightgray;
		}

		.selected.b.nobg {
			background: darkgray;
		}

		label {
			font-size: 0.5em;
		}
	</style>
</head>

<body>
	<div id="boardtext"></div>
	<input id="guides" type="checkbox" checked><label for="guides">Show potential moves</label>
	<div id="logtext"></div>
	<div id="alertcontainer" onclick="if(event.target===this)this.style.visibility='hidden'"></div>
	<script>
		"use strict"
		const WHITE = 0
		const BLACK = 1

		class Piece {
			name = "Piece"
			char = "P"
			value = 0
			dirs = []
			moved = false
			constructor(x, y, color) {
				this.x = x
				this.y = y
				this.color = color ? color : WHITE
				this.html = this.color ? '<span class="piece bf">?</span>' : '<span class="piece bf over">?</span>'
			}

			copy(piece) {
				if (!piece) piece = this
				const copy = new piece.constructor(this.x, this.y, this.color)
				copy.moved = this.moved
				return copy
			}

			get_moves(board, depth) {
				let grid = board.grid
				let moves = []
				for (let dir of this.dirs) {
					let tx = this.x + dir[0]
					let ty = this.y + dir[1]
					while (1) {
						let piece = board.xy2p([tx, ty])
						//console.log("Found", piece?.color, piece?.name, "at", tx, ty, xy2fr(tx,ty))
						if (piece === ' ') moves.push([tx, ty])
						else if (piece && piece.color !== this.color) {
							moves.push([tx, ty])
							break
						}
						else break

						tx += dir[0]
						ty += dir[1]
					}
				}
				return moves
			}

			get_threats(board, depth) {
				let grid = board.grid
				let threats = []
				for (let row in grid) {
					for (let col in grid) {
						let piece = grid[row][col]
						if (piece == ' ' || piece.color === this.color) continue
						if (piece.get_moves(board, depth + 1).find(xy => xy[0] === this.x && xy[1] === this.y)) threats.push(piece)
					}
				}
				return threats
			}

			move(board, fr, do_log) {
				this.moved = true
				const enemy = 1 - this.color
				const ox = this.x
				const oy = this.y
				let move = this.char + xy2fr(ox, oy) + (board.fr2p(fr) === ' ' ? '' : 'x') + fr
				const xy = fr2xy(fr)
				board.grid[oy][ox] = ' '
				this.x = xy[0]
				this.y = xy[1]
				board.grid[this.y][this.x] = this
				if (do_log) {
					board.log.push(move + (board.is_mate(enemy) ? '#' : (board.is_check(enemy) ? '!' : '')))
				}
			}
		}

		class Rook extends Piece {
			name = "Rook"
			char = "R"
			value = 5
			dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]]
			constructor(x, y, color) {
				super(x, y, color)
				this.html = this.color ? '<span class="piece bf">♜</span>' : '<span class="piece wf">♜</span><span class="piece bf over">♖</span>'
			}
		}

		class Knight extends Piece {
			name = "Knight"
			char = "N"
			value = 3
			constructor(x, y, color) {
				super(x, y, color)
				this.html = this.color ? '<span class="piece bf">♞</span>' : '<span class="piece wf">♞</span><span class="piece bf over">♘</span>'
			}

			get_moves(board, depth) {
				let moves = []
				for (let dir of [[-2, -1], [-2, 1], [-1, -2], [1, -2], [2, -1], [2, 1], [1, 2], [-1, 2]]) {
					let tx = this.x + dir[0]
					let ty = this.y + dir[1]
					let piece = board.xy2p([tx, ty])
					if (piece === ' ' || (piece && piece.color !== this.color)) {
						moves.push([tx, ty])
					}
				}
				return moves
			}
		}

		class Bishop extends Piece {
			name = "Bishop"
			char = "B"
			value = 3
			dirs = [[-1, -1], [1, -1], [-1, 1], [1, 1]]
			constructor(x, y, color) {
				super(x, y, color)
				this.html = this.color ? '<span class="piece bf">♝</span>' : '<span class="piece wf">♝</span><span class="piece bf over">♗</span>'
			}
		}

		class Queen extends Piece {
			name = "Queen"
			char = "Q"
			value = 9
			dirs = [[-1, -1], [1, -1], [-1, 1], [1, 1], [1, 0], [-1, 0], [0, 1], [0, -1]]
			constructor(x, y, color) {
				super(x, y, color)
				this.html = this.color ? '<span class="piece bf">♛</span>' : '<span class="piece wf">♛</span><span class="piece bf over">♕</span>'
			}
		}

		class King extends Piece {
			name = "King"
			char = "K"
			value = 10  // Officially 0; playwise 3.5 to 4.
			constructor(x, y, color) {
				super(x, y, color)
				this.html = this.color ? '<span class="piece bf">♚</span>' : '<span class="piece wf">♚</span><span class="piece bf over">♔</span>'
			}

			get_moves(board, depth) {
				if (!depth) depth = 0
				if (depth > 1) return []
				let grid = board.grid
				let moves = []
				for (let dir of [[-1, -1], [1, -1], [-1, 1], [1, 1], [1, 0], [-1, 0], [0, 1], [0, -1]]) {
					let tx = this.x + dir[0]
					let ty = this.y + dir[1]
					let piece = board.xy2p([tx, ty])
					if (piece === ' ' || (piece && piece.color !== this.color)) {
						moves.push([tx, ty])
					}
				}
				// Castling.
				/* https://chessily.com/learn-chess/king/
				The king and rook have not yet been moved in the game.
				The king is not in check before and immediately after castling.
				The king will not move through a check during castling.
				All squares between the rook and king are empty.
				*/
				if (this.get_threats(board, depth).length === 0) {
					let rank = this.color ? 8 : 1
					if (!this.moved) {
						if (!board.fr2p('a' + rank).moved) {
							// Queenside: 0-0-0
							let clear = true
							for (let i = 1; i < this.x; ++i) {
								if (grid[8 - rank][i] !== ' ') clear = false
							}
							if (clear) moves.push([2, 8 - rank])
						}
						if (!board.fr2p('h' + rank).moved) {
							// Kingside: 0-0
							let clear = true
							for (let i = 6; i > this.x; --i) {
								if (grid[8 - rank][i] !== ' ') clear = false
							}
							if (clear) moves.push([6, 8 - rank])
						}
					}
				}
				// Remove unsafe moves.
				let safe_moves = []
				for (let move of moves) {
					let new_board = board.copy()
					let new_piece = new_board.grid[this.y][this.x]
					let fr = xy2fr(...move)
					new_piece.move(new_board, fr)
					let threats = new_piece.get_threats(new_board, depth)
					if (threats.length === 0) safe_moves.push(move)
					else console.log('K', fr, '=>', threats)
				}
				if (!this.moved) {
					// Can't castle over unsafe space.
					let frs = safe_moves.map(e => xy2fr(...e))
					for (let i = safe_moves.length - 1; i >= 0; --i) {
						let fr = xy2fr(...safe_moves[i])
						if (
							(fr === 'c8' && frs.indexOf('d8') < 0) ||
							(fr === 'g8' && frs.indexOf('f8') < 0) ||
							(fr === 'c1' && frs.indexOf('d1') < 0)
						) safe_moves.splice(i, 1)
					}
				}
				// TODO: Remove covered move next to enemy king.
				return safe_moves
			}

			move(board, fr, do_log) {
				super.move(board, fr, do_log)
				let move = board.log[board.log.length - 1]
				let y = this.y
				let rank = 8 - y
				if (move === `Ke${rank}g${rank}`) { // TODO? Only 5171 according to https://en.wikipedia.org/wiki/ICCF_numeric_notation
					move = '0-0'
					board.grid[y][7].move(board, 'f' + rank)
				}
				if (move === `Ke${rank}c${rank}`) {
					move = '0-0-0'
					board.grid[y][0].move(board, 'd' + rank)
				}
				board.log[board.log.length - 1] = move
			}
		}

		class Pawn extends Piece {
			name = "Pawn"
			char = ""
			value = 1
			constructor(x, y, color) {
				super(x, y, color)
				this.html = this.color ? '<span class="piece bf">♟︎</span>' : '<span class="piece wf">♟︎</span><span class="piece bf over">♙</span>'
			}

			get_moves(board, depth) {
				let grid = board.grid
				let log = board.log
				let moves = []
				// Move straight.
				let dirs = this.color ? [[0, 1]] : [[0, -1]]
				for (let dir of dirs) {
					let tx = this.x + dir[0]
					let ty = this.y + dir[1]
					let piece = board.xy2p([tx, ty])
					if (piece === ' ') {
						moves.push([tx, ty])
						if (this.color && this.y === 1 && grid[ty + 1][tx] === ' ') moves.push([tx, ty + 1])
						if (!this.color && this.y === 6 && grid[ty - 1][tx] === ' ') moves.push([tx, ty - 1])
					}
				}
				// Capture diagonally.
				dirs = this.color ? [[-1, 1], [1, 1]] : [[-1, -1], [1, -1]]
				for (let dir of dirs) {
					let tx = this.x + dir[0]
					let ty = this.y + dir[1]
					let piece = board.xy2p([tx, ty])
					if ((piece && piece !== ' ' && piece.color !== this.color)) {
						moves.push([tx, ty])
					}
					// En passant.
					if ((this.color === BLACK && this.y === 4)
						|| (this.color === WHITE && this.y === 3)) {
						let double_jump = xy2fr(tx, this.color ? 6 : 1) + xy2fr(tx, this.color ? 4 : 3)
						if (log.slice(-1)[0] === double_jump) {
							moves.push([tx, ty])
						}
					}
				}
				return moves
			}

			move(board, fr, do_log) {
				super.move(board, fr, do_log)
				if (this.color === BLACK && this.y === 7
					|| this.color === WHITE && this.y === 0) {
					board.promote(fr, 'Q', this.color)
					let html = `
					<button onclick="board.promote('${fr}', 'Q', ${this.color}); render(board)">♛</button>
					<button onclick="board.promote('${fr}', 'B', ${this.color}); render(board)">♝</button>
					<button onclick="board.promote('${fr}', 'N', ${this.color}); render(board)">♞</button>
					<button onclick="board.promote('${fr}', 'R', ${this.color}); render(board)">♜</button>
					`
					nonblocking_alert(html)
				}
				// En passant.
				if (this.color === BLACK && this.y != 5) return
				if (this.color === WHITE && this.y != 2) return
				let double_jump = xy2fr(this.x, this.color ? 6 : 1) + xy2fr(this.x, this.color ? 4 : 3)
				let log = board.log
				if (log.slice(-2)[0] === double_jump) {
					log[log.length - 1] += ' e.p.'
					board.grid[this.y + (this.color ? -1 : 1)][this.x] = ' '
				}
			}
		}

		function xy2fr(x, y) {
			return "abcdefgh"[x] + (8 - y)
		}

		function fr2xy(fr) {
			return ["abcdefgh".indexOf(fr[0]), 8 - parseInt(fr[1])]
		}

		function render(board) {
			let grid = board.grid
			let log = board.log
			let files = `<span class="square">` + (` abcdefgh`.split('').join('</span><span class="square">')) + `</span>`
			let lines = [files]
			for (let row in grid) {
				let line = `<span class="square">${8 - row}</span>`
				for (let col in grid) {
					line += `<span id="${xy2fr(col, row)}" class="square ${'wbw'[row % 2 + col % 2]}">${grid[row][col].html || '  '}</span>`
				}
				line += `<span class="square">${8 - row}</span>`
				lines.push(line)
			}
			lines.push(files)
			logtext.innerHTML = '<ol><li>' + log.join('</li><li>') + '</li></ol>'
			boardtext.innerHTML = lines.join('\n')
			/*
			 a b c d e f g h 
			8♜♞♝♛♚♝♞♜8
			7♟︎♟︎♟︎♟︎♟︎♟︎♟︎♟︎7
			6                6
			5                5
			4                4
			3                3
			2♟︎♙♟︎♙♟︎♙♟︎♙♟︎♙♟︎♙♟︎♙♟︎♙2
			1♜♖♞♘♝♗♛♕♚♔♝♗♞♘♜♖1
			 a b c d e f g h 
			*/
			let s = boardtext.innerText.replaceAll(/([a-z])([a-z])/g, '$1 $2 ')
			for (let pair of [['♟︎♙', '♙'], ['♜♖', '♖'], ['♞♘', '♘'], ['♝♗', '♗'], ['♛♕', '♕'], ['♚♔', '♔']]) s = s.replaceAll(new RegExp(pair[0], 'g'), pair[1])
			console.log(s)
			console.log(log.join(' '))
			document.querySelectorAll('.square').forEach(el => {
				//console.log(e)
				el.onmousedown = function (e) {
					e.preventDefault()  // Stop doubleclick select.
				}
				el.onmouseup = function (e) {
					if (this.classList.contains('selected')) {
						let piece = window.selected_piece
						if (this.id !== xy2fr(piece.x, piece.y)) {
							piece.move(board, this.id, true)
							render(board)
						}
						return
					}
					let piece = board.fr2p(this.id)
					if (!piece || piece === ' ') return
					window.selected_piece = piece
					document.querySelectorAll('.selected').forEach(el => {
						el.classList.remove('selected')
						el.classList.remove('nobg')
					})
					this.classList.add('selected')
					let moves = piece.get_moves(board)
					for (let move of moves) {
						let square = document.getElementById(xy2fr(...move))
						square.classList.add('selected')
						if (!guides.checked) square.classList.add('nobg')
					}
				}
			})
		}

		function nonblocking_alert(html) {
			if (getComputedStyle(alertcontainer).visibility == 'hidden') {
				alertcontainer.innerText = ''
				alertcontainer.style.visibility = 'visible'
			}
			const d = document.createElement('div')
			d.className = 'alert'
			d.innerHTML = html
			alertcontainer.appendChild(d)
		}

		class Board {
			log = []
			grid = [[], [], [], [], [], [], [], []]

			reset() {
				this.log = []
				this.grid = [
					[new Rook(0, 0, BLACK), new Knight(1, 0, BLACK), new Bishop(2, 0, BLACK), new Queen(3, 0, BLACK), new King(4, 0, BLACK), new Bishop(5, 0, BLACK), new Knight(6, 0, BLACK), new Rook(7, 0, BLACK)],
					[new Pawn(0, 1, BLACK), new Pawn(1, 1, BLACK), new Pawn(2, 1, BLACK), new Pawn(3, 1, BLACK), new Pawn(4, 1, BLACK), new Pawn(5, 1, BLACK), new Pawn(6, 1, BLACK), new Pawn(7, 1, BLACK)],
					[' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],
					[' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],
					[' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],
					[' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],
					[new Pawn(0, 6), new Pawn(1, 6), new Pawn(2, 6), new Pawn(3, 6), new Pawn(4, 6), new Pawn(5, 6), new Pawn(6, 6), new Pawn(7, 6)],
					[new Rook(0, 7), new Knight(1, 7), new Bishop(2, 7), new Queen(3, 7), new King(4, 7), new Bishop(5, 7), new Knight(6, 7), new Rook(7, 7)],
				]
			}

			get_king(color) {
				for (let row in this.grid) {
					for (let col in this.grid) {
						let piece = this.grid[row][col]
						if (piece.name === "King" && piece.color === color) return piece
					}
				}
			}

			is_check(color) {
				return this.get_king(color).get_threats(this).length > 0
			}

			is_mate(color) {
				let saves = []
				for (let row in this.grid) {
					for (let col in this.grid) {
						let piece = this.grid[row][col]
						if (piece.color === color) {
							const moves = piece.get_moves(this)
							for (let move of moves) {
								let new_board = this.copy()
								let new_piece = new_board.grid[row][col]
								new_piece.move(new_board, xy2fr(...move))  // TODO: Castling? Limit depth again.
								if (!new_board.is_check(color)) saves.push(new_piece.char + xy2fr(...move))
							}
						}
					}
				}
				if (saves.length > 0) console.log("save by", saves)
				return this.is_check(color) && this.get_king(color).get_moves(this).length === 0 && saves.length === 0
			}

			copy() {
				let new_board = new Board()
				new_board.log = [...this.log]
				for (let row in this.grid) {
					for (let col in this.grid) {
						let piece = this.grid[row][col]
						new_board.grid[row][col] = (piece === ' ') ? ' ' : piece.copy()
					}
				}
				return new_board
			}

			xy2p(xy) {
				if (xy[1] < 0 || xy[1] > 7 || xy[0] < 0 || xy[0] > 7) return ''
				return this.grid[xy[1]][xy[0]]
			}

			fr2p(fr) {
				const xy = fr2xy(fr)
				if (xy[0] >= 0 && xy[1] >= 0) return this.grid[xy[1]][xy[0]]
				return ''
			}

			promote(fr, kind, color) {
				let [x, y] = fr2xy(fr)
				switch (kind) {
					case 'Q':
						grid[y][x] = new Queen(x, y, color)
						break
					case 'B':
						grid[y][x] = new Bishop(x, y, color)
						break
					case 'N':
						grid[y][x] = new Knight(x, y, color)
						break
					case 'R':
						grid[y][x] = new Rook(x, y, color)
						break
				}
			}
		}

		let board = new Board()
		board.reset()
		render(board)
	</script>
</body>

</html>