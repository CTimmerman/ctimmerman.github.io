<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Chess by Cees Timmerman, 2022-12-28</title>
	<link id="favicon" rel="icon" href="lib/rook.png">
	<style>
		/* Doesn't work in console.
		@font-face {
			font-family: 'TrueMonospace';
			src: url('fonts/GnuUnifontFull-Pm9P.ttf');
		}
		*/
		* {
			--bgcolor: brown;
			--fgcolor: yellow;
			color: var(--fgcolor);
			background-color: var(--bgcolor);
			border-color: var(--fgcolor);
			font-size: 10mm;
			line-height: 1em;
		}

		button {
			cursor: pointer;
			vertical-align: top;
		}

		input[type=number] {
			font-size: medium;
			vertical-align: middle;
			width: 2em;
		}

		#alertcontainer {
			margin: 0;
			left: 0;
			top: 0;
			width: 100%;
			height: 100%;
			position: fixed;
			overflow: auto;
			display: flex;
			flex-wrap: wrap;
			align-items: center;
			/* vertical */
			justify-content: center;
			/* horizontal */
			visibility: hidden;
			background-color: rgba(0, 0, 0, 0.5);
		}

		.alert {
			/* margin: auto; */
			border: 1px solid var(--fgcolor);
			border-radius: 5px;
			box-shadow: 10px 10px 10px rgb(0 0 0 / 20%);
			padding: 1em;
			/* background-color: var(--bgcolor); */
			/* font-size: 200%; */
			text-align: center;
		}

		#boardtext {
			display: block;
			/*font-family: TrueMonospace;*/
			font-size: 0;
			/* Gets rid of newline spaces. */
			margin: 1em 0;
			position: relative;
			/* For relative position absolute children. */
			white-space: pre;
		}

		.w {
			background-color: lightgrey;
		}

		.b {
			background-color: darkgrey;
		}

		.wf {
			color: white;
		}

		.bf {
			color: black;
		}

		.square {
			height: 1em;
			width: 1em;
			display: inline-block;
			line-height: 1em;
			text-align: center;
			cursor: pointer;
		}

		.piece {
			background-color: transparent;
			height: 1em;
			line-height: 1em;
			width: 1em;
			text-align: center;
			display: block;
			pointer-events: none;
			position: absolute;
			transition: 0.4s;
		}

		.selected.w {
			background: radial-gradient(lightgray 30%, yellow);
		}

		.selected.b {
			background: radial-gradient(darkgray 30%, yellow);
		}

		.selected.w.nobg {
			background: lightgray;
		}

		.selected.b.nobg {
			background: darkgray;
		}

		label {
			font-size: 0.5em;
		}

		ol {
			list-style-position: inside;
		}
	</style>
</head>

<body>
	<div id="boardtext"></div>
	<input id="guides" type="checkbox" checked><label for="guides">Show potential moves</label><br>
	<label for="ai_level">AI level </label><input id="ai_level" type="number" value="2" min="1">
	<input id="black_ai_box" type="checkbox" checked><label for="black_ai_box">black</label>
	<input id="white_ai_box" type="checkbox"><label for="white_ai_box">white</label><br>
	<input id="speak" type="checkbox" checked><label for="speak">Speak</label>
	<input id="speak_black" type="checkbox"><label for="speak_black">black moves</label>
	<input id="speak_white" type="checkbox"><label for="speak_white">white moves</label>
	<div id="logtext"></div>
	<div style="display:flex">
		<button onclick="replay(movetextbox.value)" type="button">Replay</button>
		<textarea id="movetextbox" type="text" placeholder="movetext"></textarea>
	</div>
	<div style="display:flex">
		<button onclick="fenbox.value = board.fen_export()" type="button">Export</button>
		<button onclick="board.fen_import(fenbox.value)" type="button">Import</button>
		<textarea id="fenbox" type="text" placeholder="FEN"></textarea>
	</div>
	<div id="alertcontainer" onclick="if(event.target===this)this.style.visibility='hidden'"></div>
	<script type="module">
		"use strict"
		const SAFARI = navigator.userAgent.indexOf('Safari') > -1
		const WINDOWS = navigator.userAgent.indexOf('Windows') > -1
		const COLORS = navigator.userAgent.indexOf('Chrome') > -1
		const MONOSPACE = !WINDOWS
		const WHITE = 0
		const BLACK = 1

		function clog(msg) {
			console.log("%c" + msg, "font-family: monospace; color: black; background-color: white")
		}

		class Piece {
			name = "Piece"
			char = "P"
			value = 0
			dirs = []
			moved = false
			constructor(x, y, color, board_in) {
				this.x = x
				this.y = y
				this.color = color ? color : WHITE
				this.board = board_in || board
			}

			copy(board_in) {
				const copy = new this.constructor(this.x, this.y, this.color, board_in)
				copy.moved = this.moved
				return copy
			}

			get_moves() {
				const grid = this.board.grid
				const moves = []
				for (let dir of this.dirs) {
					let tx = this.x + dir[0]
					let ty = this.y + dir[1]
					while (1) {
						let piece = this.board.xy2p([tx, ty])
						if (piece === ' ') moves.push([tx, ty])
						else if (piece && piece.color !== this.color) {
							moves.push([tx, ty])
							break
						}
						else break

						tx += dir[0]
						ty += dir[1]
					}
				}
				return moves
			}

			get_threats(depth) {
				if ((depth || 0) > 1) return []
				const grid = this.board.grid
				const threats = []
				for (let row in grid) {
					for (let col in grid) {
						const piece = grid[row][col]
						if (piece == ' ' || piece.color === this.color) continue
						if (piece.get_moves(depth).find(xy => xy[0] === this.x && xy[1] === this.y)) threats.push(piece)
					}
				}
				return threats
			}

			move(fr, do_log) {
				const board = this.board
				this.moved = true
				const ox = this.x
				const oy = this.y
				const capture = board.fr2p(fr)
				const move = this.char + xy2fr(ox, oy) + (capture === ' ' ? '' : 'x') + fr
				const xy = fr2xy(fr)
				board.grid[oy][ox] = ' '
				this.x = xy[0]
				this.y = xy[1]
				board.grid[this.y][this.x] = this
				if (do_log) {
					if (capture !== ' ') {
						board.captured.push(capture)
						say('Took ' + capture.name)
					}
					board.log_check(move, 1 - this.color)
				}
			}
		}

		class Rook extends Piece {
			name = "Rook"
			char = "R"
			value = 5
			dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]]
		}

		class Knight extends Piece {
			name = "Knight"
			char = "N"
			value = 3

			get_moves() {
				let moves = []
				for (let dir of [[-2, -1], [-2, 1], [-1, -2], [1, -2], [2, -1], [2, 1], [1, 2], [-1, 2]]) {
					const tx = this.x + dir[0]
					const ty = this.y + dir[1]
					const piece = this.board.xy2p([tx, ty])
					if (piece === ' ' || (piece && piece.color !== this.color)) {
						moves.push([tx, ty])
					}
				}
				return moves
			}
		}

		class Bishop extends Piece {
			name = "Bishop"
			char = "B"
			value = 3
			dirs = [[-1, -1], [1, -1], [-1, 1], [1, 1]]
		}

		class Queen extends Piece {
			name = "Queen"
			char = "Q"
			value = 9
			dirs = [[-1, -1], [1, -1], [-1, 1], [1, 1], [1, 0], [-1, 0], [0, 1], [0, -1]]
		}

		class King extends Piece {
			name = "King"
			char = "K"
			value = 10  // Officially 0; playwise 3.5 to 4.

			get_moves(depth) {
				if (!depth) depth = 0
				if (depth > 1) return []
				const board = this.board
				const grid = board.grid
				const moves = []
				for (let dir of [[-1, -1], [1, -1], [-1, 1], [1, 1], [1, 0], [-1, 0], [0, 1], [0, -1]]) {
					let tx = this.x + dir[0]
					let ty = this.y + dir[1]
					let piece = board.xy2p([tx, ty])
					if (piece === ' ' || (piece && piece.color !== this.color)) {
						moves.push([tx, ty])
					}
				}
				// Castling.
				/* https://chessily.com/learn-chess/king/
				The king and rook have not yet been moved in the game.
				The king is not in check before and immediately after castling.
				The king will not move through a check during castling.
				All squares between the rook and king are empty.
				*/
				if (!this.moved && this.get_threats(depth + 1).length === 0) {
					const rank = this.color ? 8 : 1
					let piece = board.fr2p('a' + rank)
					if (piece.char === 'R' && !piece.moved) {
						let clear = true
						for (let i = 1; i < this.x; ++i) {
							if (grid[8 - rank][i] !== ' ') clear = false
						}
						if (clear) moves.push([2, 8 - rank])
					}
					piece = board.fr2p('h' + rank)
					if (piece.char === 'R' && !piece.moved) {
						let clear = true
						for (let i = 6; i > this.x; --i) {
							if (grid[8 - rank][i] !== ' ') clear = false
						}
						if (clear) moves.push([6, 8 - rank])
					}
				}
				// Remove unsafe moves.
				let safe_moves = []
				for (let move of moves) {
					if (board.xy2p(move).char === "K") {
						// Happens in deep thought.
						//const foo = [...board.log]; let i = 1; let j = 0; let s = ''; while (foo.length > 0) { s += `${j}. ${foo.shift() + ' ' + foo.shift()} `; i += 2; j += 1 }; clog(s); //.replaceAll(/([A-Z]?)([a-h][0-8])(x?[a-h][0-8])/g, '$1$3'));
						safe_moves.push(move)
					} else {
						let new_board = board.copy()
						let new_piece = new_board.grid[this.y][this.x]
						let fr = xy2fr(...move)
						new_piece.move(fr)
						if (new_piece.get_threats(depth + 1).length === 0) safe_moves.push(move)
					}
				}
				if (!this.moved) {
					// Can't castle over unsafe space.
					const frs = safe_moves.map(e => xy2fr(...e))
					for (let i = safe_moves.length - 1; i >= 0; --i) {
						let fr = xy2fr(...safe_moves[i])
						if (
							(fr === 'c8' && frs.indexOf('d8') < 0) ||
							(fr === 'g8' && frs.indexOf('f8') < 0) ||
							(fr === 'c1' && frs.indexOf('d1') < 0)
						) safe_moves.splice(i, 1)
					}
				}
				return safe_moves
			}

			move(fr, do_log) {
				super.move(fr, do_log)
				if (!do_log) return
				const board = this.board
				let move = board.log.pop()
				const y = this.y
				const rank = 8 - y
				if (move === `Ke${rank}g${rank}`) {
					move = '0-0'
					if (do_log) say("Castle.")
					board.grid[y][7].move('f' + rank)
				}
				if (move === `Ke${rank}c${rank}`) {
					move = '0-0-0'
					if (do_log) say("Castle.")
					board.grid[y][0].move('d' + rank)
				}
				board.log_check(move, 1 - this.color)
			}
		}

		class Pawn extends Piece {
			name = "Pawn"
			char = ""
			value = 1

			get_moves() {
				const board = this.board
				const grid = board.grid
				const log = board.log
				const moves = []
				// Move straight.
				let dirs = this.color ? [[0, 1]] : [[0, -1]]
				for (let dir of dirs) {
					const tx = this.x + dir[0]
					const ty = this.y + dir[1]
					const piece = board.xy2p([tx, ty])
					if (piece === ' ') {
						moves.push([tx, ty])
						if (this.color && this.y === 1 && grid[ty + 1][tx] === ' ') moves.push([tx, ty + 1])
						if (!this.color && this.y === 6 && grid[ty - 1][tx] === ' ') moves.push([tx, ty - 1])
					}
				}
				// Capture diagonally.
				dirs = this.color ? [[-1, 1], [1, 1]] : [[-1, -1], [1, -1]]
				for (let dir of dirs) {
					const tx = this.x + dir[0]
					const ty = this.y + dir[1]
					const piece = board.xy2p([tx, ty])
					if ((piece && piece !== ' ' && piece.color !== this.color)) {
						moves.push([tx, ty])
					}
					// En passant.
					if ((this.color === BLACK && this.y === 4)
						|| (this.color === WHITE && this.y === 3)) {
						const double_jump = xy2fr(tx, this.color ? 6 : 1) + xy2fr(tx, this.color ? 4 : 3)
						if (log.slice(-1)[0] === double_jump) {
							moves.push([tx, ty])
						}
					}
				}
				return moves
			}

			move(fr, do_log) {
				super.move(fr, do_log)
				const log = this.board.log
				if ((this.y === 0 && this.color === WHITE)
					|| (this.y === 7 && this.color === BLACK)) {
					this.board.promote(fr, 'Q', this.color)
					if (do_log) {
						log[log.length - 1] += 'Q'
						say("Promotion.")
					}
				}
				// En passant.
				if (this.color === BLACK && this.y != 5) return
				if (this.color === WHITE && this.y != 2) return
				const double_jump = xy2fr(this.x, this.color ? 6 : 1) + xy2fr(this.x, this.color ? 4 : 3)
				if (log.slice(-2)[0].slice(0, 4) === double_jump) {
					this.board.grid[this.y + (this.color ? -1 : 1)][this.x] = ' '
					log[log.length - 1] += ' e.p.'
					if (do_log) say("En passant.")
				}
			}
		}

		class Board {
			grid = [[], [], [], [], [], [], [], []]
			log = []
			captured = []

			reset() {
				this.grid = [
					[new Rook(0, 0, BLACK), new Knight(1, 0, BLACK), new Bishop(2, 0, BLACK), new Queen(3, 0, BLACK), new King(4, 0, BLACK), new Bishop(5, 0, BLACK), new Knight(6, 0, BLACK), new Rook(7, 0, BLACK)],
					[new Pawn(0, 1, BLACK), new Pawn(1, 1, BLACK), new Pawn(2, 1, BLACK), new Pawn(3, 1, BLACK), new Pawn(4, 1, BLACK), new Pawn(5, 1, BLACK), new Pawn(6, 1, BLACK), new Pawn(7, 1, BLACK)],
					[' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],
					[' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],
					[' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],
					[' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],
					[new Pawn(0, 6), new Pawn(1, 6), new Pawn(2, 6), new Pawn(3, 6), new Pawn(4, 6), new Pawn(5, 6), new Pawn(6, 6), new Pawn(7, 6)],
					[new Rook(0, 7), new Knight(1, 7), new Bishop(2, 7), new Queen(3, 7), new King(4, 7), new Bishop(5, 7), new Knight(6, 7), new Rook(7, 7)],
				]
				this.log = []
				this.captured = []
			}

			fen_export() {
				let ppd = ''
				for (let row = 0; row < 8; ++row) {
					let spaces = 0
					for (let col = 0; col < 8; ++col) {
						const p = this.grid[row][col]
						if (p === ' ') {
							++spaces
							if (col === 7) ppd += spaces
						} else {
							if (spaces) {
								ppd += spaces
								spaces = 0
							}
							switch (p.char) {
								case '': ppd += p.color ? 'p' : 'P'; break
								case 'R': ppd += p.color ? 'r' : 'R'; break
								case 'N': ppd += p.color ? 'n' : 'N'; break
								case 'B': ppd += p.color ? 'b' : 'B'; break
								case 'Q': ppd += p.color ? 'q' : 'Q'; break
								case 'K': ppd += p.color ? 'k' : 'K'; break
							}
						}
					}
					if (row < 7) ppd += '/'
				}
				let active_color = 'wb'[this.log.length % 2]
				let castling_availability = ''
				if (!this.get_king(WHITE).moved) {
					if (!this.xy2p([7, 7]).moved) castling_availability += 'K'
					if (!this.xy2p([0, 7]).moved) castling_availability += 'Q'
				}
				if (!this.get_king(BLACK).moved) {
					if (!this.xy2p([7, 0]).moved) castling_availability += 'k'
					if (!this.xy2p([0, 0]).moved) castling_availability += 'q'
				}
				let ep_target = '-'
				let mo = this.log[this.log.length - 1]?.match(/^[a-h][27]([a-h][45])/)
				if (mo) {
					if (mo[1][1] === '4') ep_target = mo[1][0] + '3'
					else ep_target = mo[1][0] + '6'
				}
				let halfmove_clock = 0
				for (let i = this.log.length - 1; i >= 0; --i) {
					const s = this.log[i]
					// Reset after capture or pawn move.
					if (s.indexOf('x') > -1 || s.match(/^[a-h]/)) break
					++halfmove_clock
				}
				let fullmove_number = 1 + Math.floor(this.log.length / 2)

				return [ppd, active_color, castling_availability || '-', ep_target, halfmove_clock, fullmove_number].join(' ')
			}

			fen_import(fen) {
				// e.g. "2b5/2p5/4p3/4r1kp/8/5K2/r2q4/8 b KQkq - 0 20" or "8/5k2/3p4/1p1Pp2p/pP2Pp1P/P4P1K/8/8 b - - 99 50"
				let [ppd, active_color, castling_availability, ep_target, halfmove_clock, fullmove_number] = fen.split(' ')
				this.grid = []
				this.log = []
				this.captured = []
				for (let i = 0; i < 8; ++i) this.grid.push([' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '])
				let row = 0
				let col = 0
				for (let line of ppd.split('/')) {
					for (let char of line) {
						let piece = ' '
						switch (char) {
							case 'r': piece = new Rook(col, row, BLACK); break
							case 'n': piece = new Knight(col, row, BLACK); break
							case 'b': piece = new Bishop(col, row, BLACK); break
							case 'q': piece = new Queen(col, row, BLACK); break
							case 'k': piece = new King(col, row, BLACK); break
							case 'p': piece = new Pawn(col, row, BLACK); break

							case 'R': piece = new Rook(col, row); break
							case 'N': piece = new Knight(col, row); break
							case 'B': piece = new Bishop(col, row); break
							case 'Q': piece = new Queen(col, row); break
							case 'K': piece = new King(col, row); break
							case 'P': piece = new Pawn(col, row); break
							default:
								col += parseInt(char) - 1
						}
						this.grid[row][col] = piece
						if (piece !== ' ') piece.moved = true
						++col
					}
					col = 0
					++row
				}
				if (castling_availability.indexOf('K') > -1) {
					this.grid[7][4].moved = false
					this.grid[7][7].moved = false
				}
				if (castling_availability.indexOf('Q') > -1) {
					this.grid[7][4].moved = false
					this.grid[7][0].moved = false
				}
				if (castling_availability.indexOf('k') > -1) {
					this.grid[0][4].moved = false
					this.grid[0][7].moved = false
				}
				if (castling_availability.indexOf('q') > -1) {
					this.grid[0][4].moved = false
					this.grid[0][0].moved = false
				}
				for (let i = 1; i <= parseInt(fullmove_number - 1) * 2 + (active_color === 'b' ? 1 : 0); ++i) this.log.push('?')
				if (ep_target !== '-') {
					let [file, rank] = ep_target
					if (rank === '4') this.log[this.log.length - 1] = `${file}3${file}5`
					else this.log[this.log.length - 1] = `${file}5${file}7`
				}
				render(this)
			}

			get_king(color) {
				for (let row in this.grid) {
					for (let col in this.grid) {
						const piece = this.grid[row][col]
						if (piece.char === "K" && piece.color === color) return piece
					}
				}
			}

			get_pieces(color) {
				const rv = []
				for (let row in this.grid) {
					for (let col in this.grid) {
						const piece = this.grid[row][col]
						if (piece.color === color) rv.push(piece)
					}
				}
				return rv
			}

			is_check(color) {
				const king = this.get_king(color)
				return !!king && king.get_threats().length > 0
			}

			is_mate(color) {
				if (!this.is_check(color)) return false
				const king = this.get_king(color)
				const saves = []
				for (let row in this.grid) {
					for (let col in this.grid) {
						let piece = this.grid[row][col]
						if (piece.color !== color) continue
						const moves = piece.get_moves()
						for (let move of moves) {
							const new_board = this.copy()
							const new_piece = new_board.grid[row][col]
							new_piece.move(xy2fr(...move))
							if (!new_board.is_check(color)) saves.push(new_piece.char + xy2fr(piece.x, piece.y) + xy2fr(...move))
						}
					}
				}
				return this.is_check(color) && king.get_moves().length === 0 && saves.length === 0
			}

			copy() {
				const new_board = new Board()
				new_board.log = [...this.log]
				new_board.captured = [...this.captured]
				for (let row in this.grid) {
					for (let col in this.grid) {
						const piece = this.grid[row][col]
						if (piece === ' ') {
							new_board.grid[row][col] = ' '
						} else {
							new_board.grid[row][col] = piece.copy(new_board)
						}
					}
				}
				return new_board
			}

			xy2p(xy) {
				if (xy[1] < 0 || xy[1] > 7 || xy[0] < 0 || xy[0] > 7) return ''
				return this.grid[xy[1]][xy[0]]
			}

			fr2p(fr) {
				const xy = fr2xy(fr)
				if (xy[0] >= 0 && xy[1] >= 0) return this.grid[xy[1]][xy[0]]
				return ''
			}

			log_check(move, color) {
				let c = this.is_check(color) ? (this.is_mate(color) ? '#' : '+') : ''
				if (c === '+') say('Check.')
				else if (c === '#') {
					c += color ? ' 1-0' : ' 0-1'; say('Checkmate. ' + ['Black', 'White'][color] + ' wins!')
					clearInterval(timer)
				}
				this.log.push(move + c)
			}

			promote(fr, kind, color) {
				const [x, y] = fr2xy(fr)
				switch (kind) {
					case 'Q':
						this.grid[y][x] = new Queen(x, y, color)
						break
					case 'B':
						this.grid[y][x] = new Bishop(x, y, color)
						break
					case 'N':
						this.grid[y][x] = new Knight(x, y, color)
						break
					case 'R':
						this.grid[y][x] = new Rook(x, y, color)
						break
				}
			}
		}


		window.xy2fr = function xy2fr(x, y) {
			return "abcdefgh"[x] + (8 - y)
		}

		window.fr2xy = function fr2xy(fr) {
			return ["abcdefgh".indexOf(fr[0]), 8 - parseInt(fr[1])]
		}

		const icons = {
			'0': '♙', '1': '♟︎',
			'R0': '♖', 'R1': '♜',
			'N0': '♘', 'N1': '♞',
			'B0': '♗', 'B1': '♝',
			'Q0': '♕', 'Q1': '♛',
			'K0': '♔', 'K1': '♚',
		}

		window.render = function render(board) {
			const grid = board.grid
			const log = board.log

			let files = `<span class="square">` + (` abcdefgh`.split('').join('</span><span class="square">')) + `</span>`
			let lines = [files + `<span id="clock1"></span> <span id="caps1">${board.captured.filter(e => e.color === WHITE).map(e => icons[e.char + e.color]).join('')}</span>`]
			for (let row in grid) {
				let line = `<span class="square">${8 - row}</span>`
				for (let col in grid) {
					line += `<span id="${xy2fr(col, row)}" class="square ${'wb'[(row % 2 + col % 2) % 2]}">  </span>`
				}
				line += `<span class="square">${8 - row}</span>`
				lines.push(line)
			}
			lines.push(files + `<span id="clock0"></span> <span id="caps0">${board.captured.filter(e => e.color === BLACK).map(e => icons[e.char + e.color]).join('')}</span>`)

			files = ' abcdefgh '
			let blank = ' '
			if (!MONOSPACE) {
				files = ' a b c d e f g h '
				blank = '  '
			}
			let text_lines = [files]
			for (let row in grid) {
				let text_line = COLORS ? `${8 - row}\x1B[30m` : `${8 - row}`
				for (let col in grid) {
					if (COLORS) text_line += ['\x1B[47m', '\x1B[100m'][(row % 2 + col % 2) % 2]
					const p = grid[row][col]
					if (p === ' ') {
						text_line += COLORS ? ' ' : ' .'[(row % 2 + col % 2) % 2]
						if (!MONOSPACE) text_line += ' '
						continue
					}
					text_line += icons[p.char + p.color]
					let html = ''
					if (p.color) html = `<span class="piece bf">${icons[p.char + '1']}</span>`
					else html = `<span class="piece wf">${icons[p.char + '1']}</span><span class="piece bf">${icons[p.char + '0']}</span>`
					lines.push(`<div id="p${xy2fr(col, row)}" class='piece' style='left: ${1 + parseInt(col)}em; top: ${1 + parseInt(row)}em'>${html}</div>`)
				}
				text_lines.push(text_line + (COLORS ? `\x1B[m${8 - row}` : `${8 - row}`))
			}
			text_lines.push(files)
			clog(text_lines.join('\n'))
			boardtext.innerHTML = lines.join('\n')

			let html = ''
			let txt = ''
			for (let i = 0; i < log.length; i += 2) {
				html += `<li>${log[i]} ${log[i + 1] || ''}</li>`
				txt += `${1 + i / 2}. ${log[i]} ${log[i + 1] || ''} `
			}
			logtext.innerHTML = `<ol>${html}</ol>`

			clog(board.captured.map(e => icons[e.char + e.color]).join(''))
			if (txt.length > 77) clog(`...${txt.slice(-77)}`)
			else clog(txt)

			show_clock()
			document.querySelectorAll('.square').forEach(el => {
				el.onmousedown = function (e) {
					e.preventDefault()  // Stop doubleclick select.
				}
				el.onmouseup = function (e) {
					if (this.classList.contains('selected')) {
						if (start_fr && start_fr !== this.id) {
							show_move(start_fr, this.id, true)
							start_fr = null
							return
						}
					}
					document.querySelectorAll('.selected').forEach(el => {
						el.classList.remove('selected')
						el.classList.remove('nobg')
					})
					const piece = board.fr2p(this.id)
					if (!piece || piece === ' ' || this.id === window.start_fr) {
						window.start_fr = null
						return
					}
					window.start_fr = this.id
					this.classList.add('selected')
					const moves = piece.get_moves()
					for (let move of moves) {
						// Limit if in check.
						let new_board = board.copy()
						let new_piece = new_board.grid[piece.y][piece.x]
						let fr = xy2fr(...move)
						new_piece.move(fr)
						if (new_board.is_check(piece.color)) continue

						let square = document.getElementById(xy2fr(...move))
						square.classList.add('selected')
						if (!guides.checked) square.classList.add('nobg')
					}
				}
			})
		}

		function random_choice(array) {
			return array[Math.floor(Math.random() * array.length)]
		}

		function prune_move(piece, move) {
			piece.moves = piece.moves.filter(m => m[0] !== move[0] || m[1] !== move[1])
		}

		window.ai_move = async function ai_move(board_in, depth, color) {
			if (typeof depth === "undefined") depth = 0
			else if (depth >= ai_level.value) return

			var start_time = performance.now()
			let my_board = board
			if (typeof board_in !== "undefined") my_board = board_in
			if (typeof color === "undefined") color = 1 - my_board.log.length % 2
			let pieces = my_board.get_pieces(color)
			let total_moves = 0
			pieces.forEach(p => { p.moves = p.get_moves(); total_moves += p.moves.length })
			pieces = pieces.filter(p => p.moves.length > 0)
			let best_score = 9999
			let best_move = null
			let best_piece = null
			let max_think = 128  // offense
			if (depth === 1) max_think = 100  // defense
			else if (depth > 1) max_think = 2  // trap
			for (let i = 0; i < max_think; ++i) {
				if (pieces.length < 1) break
				const piece = random_choice(pieces)
				const move = random_choice(piece.moves)
				// Eval move.
				const new_board = my_board.copy()
				const new_piece = new_board.grid[piece.y][piece.x]
				const capture = new_board.grid[move[1]][move[0]]
				if (capture.char === "K") {
					clog("Capturing king.")
					say("You are already dead.")
					best_move = move
					best_piece = piece
					break
				}
				new_piece.move(xy2fr(...move))
				if (new_board.is_check(color)) {
					prune_move(piece, move)
					pieces = pieces.filter(p => p.moves.length > 0)
					continue  // Keep own king safe.
				}
				// if (new_board.is_mate(1 - color)) {
				// 	best_move = move
				// 	best_piece = piece
				// 	break
				// }
				// Set response. TODO: pass breadth first to not make dumb moves.
				let enemy_move = true
				if (depth < ai_level.value - 1) enemy_move = await ai_move(new_board, depth + 1, 1 - color)
				if (enemy_move) {
					const my_score = new_board.get_pieces(color).reduce((sum, el) => sum + el.value, 0)
					const enemy_score = new_board.get_pieces(1 - color).reduce((sum, el) => sum + el.value, 0)
					const score = enemy_score - my_score
					if (score > best_score) {
						prune_move(piece, move)
						pieces = pieces.filter(p => p.moves.length > 0)
					} else if (score < best_score) {
						best_score = score
						best_move = move
						best_piece = piece
					}
				} else {
					// Draw or better!
					const my_score = new_board.get_pieces(color).reduce((sum, el) => sum + el.value, 0)
					const enemy_score = new_board.get_pieces(1 - color).reduce((sum, el) => sum + el.value, 0)
					const score = enemy_score - my_score
					console.log("Draw at", enemy_score, "-", my_score, "=", score)
					best_score = -90
					best_move = move
					best_piece = piece
					if (new_board.is_mate(1 - color)) break
				}
				if (i % 20 === 0) {
					await sleep(1)  // Update GUI.
					if(performance.now() - start_time > 10e3) {
						console.log("...")
						break
					}
				}
			}
			if (depth > 0) {
				if (best_piece) best_piece.move(xy2fr(...best_move))
			} else {
				if (best_piece) await show_move(xy2fr(best_piece.x, best_piece.y), xy2fr(...best_move))
				else {
					my_board.log.push('½–½')
					say('Draw.')
					clearInterval(timer)
					render(my_board)
				}
				console.log(`Level ${ai_level.value} max_think ${max_think} took ${ms2time(performance.now() - start_time)} at ${new Date()}`)
			}
			return best_move
		}

		import sleep from './lib/sleep.mjs'
		import say_it from './lib/say.mjs'
		window.say = function say(msg) {
			console.log(msg)
			if (speak.checked) {
				say_it(msg, WINDOWS ? 1.9 : 1, 1, "en-UK")
			}
		}

		async function show_move(start_fr, stop_fr, is_human) {
			favicon.href = 'lib/rook.png'
			const piece = board.fr2p(start_fr)
			const c = piece.char
			const color = piece.color

			if ((color === BLACK && speak_black.checked) ||
				(color === WHITE && speak_white.checked)) say(`${start_fr} ${stop_fr}`.toUpperCase())  // Even uppercase fails "a7 a5" on MacOS!

			const style = document.getElementById('p' + start_fr).style
			const [x, y] = fr2xy(stop_fr)
			style.left = (1 + x) + 'em'
			style.top = (1 + y) + 'em'

			piece.move(stop_fr, true)
			await sleep(400)
			render(board)
			document.getElementById(start_fr).classList.add('selected')
			document.getElementById(stop_fr).classList.add('selected')
			await sleep(400)

			if (is_human && c === '' && (
				(color === BLACK && y === 7) ||
				(color === WHITE && y === 0))) {
				let html = `
					<button onclick="promote('${stop_fr}', 'Q', ${color})">♛</button>
					<button onclick="promote('${stop_fr}', 'B', ${color})">♝</button>
					<button onclick="promote('${stop_fr}', 'N', ${color})">♞</button>
					<button onclick="promote('${stop_fr}', 'R', ${color})">♜</button>
					`
				modal(html)
				while (getComputedStyle(alertcontainer).visibility === 'visible') await (sleep(1000))
			}

			if (board.log[board.log.length - 1].indexOf('#') > -1) return
			const max_moves = 75
			if (board.log.length > max_moves && !board.log.slice(-max_moves).some(s => s.indexOf('x') > -1 || s.match(/^[a-h]/))) {
				const msg = `${max_moves} moves without checkmate, capture, or pawn move. Draw.`
				clog(msg)
				say(msg)
				clearInterval(timer)
				return
			}
			start_clock(1 - color)
			if (black_ai_box.checked || white_ai_box.checked) {
				favicon.href = 'lib/think.png'
				if (ai_level.value < 2 || board.log[board.log.length - 1].indexOf('x') > -1) await sleep(1000)
				else await sleep(400)
				ai_move(board, 0, 1 - color)
			}
		}

		window.promote = function promote(fr, kind, color) {
			alertcontainer.style.visibility = 'hidden'
			board.promote(fr, kind, color)
			say('Promote to ' + board.fr2p(fr).name)
			board.log_check(board.log.pop().slice(0, -1) + kind, 1 - color)
			render(board)
		}

		window.modal = function nonblocking_alert(html) {
			if (getComputedStyle(alertcontainer).visibility == 'hidden') {
				alertcontainer.innerText = ''
				alertcontainer.style.visibility = 'visible'
			}
			const d = document.createElement('div')
			d.className = 'alert'
			d.innerHTML = html
			alertcontainer.appendChild(d)
		}

		window.timer = null
		const clock_start = [0, 0]
		const clock_running = [false, false]
		const clock_ms = [0, 0]
		function start_clock(color) {
			clock_start[color] = performance.now()
			clock_running[color] = true
			clock_running[1 - color] = false
			clock_ms[1 - color] += performance.now() - clock_start[1 - color]
			show_clock()
			clearInterval(timer)
			timer = setInterval(show_clock, 1000)
		}
		window.show_clock = function show_clock() {
			for (let color of [0, 1]) {
				const el = document.getElementById('clock' + color)
				if (clock_running[color]) el.innerText = ms2time(clock_ms[color] + performance.now() - clock_start[color])
				else el.innerText = ms2time(clock_ms[color])
			}
		}

		window.ms2time = function ms2time(ms) {
			const secs = ms / 1000
			return ('0' + Math.floor(secs / 60)).slice(-2) + ':' + ('0' + Math.floor(secs % 60)).slice(-2)
		}

		window.replay = async function replay(movetext) {
			board.reset()
			render(board)
			const bai = black_ai_box.checked
			const wai = white_ai_box.checked
			const spk = speak.checked
			black_ai_box.checked = false
			white_ai_box.checked = false
			speak.checked = false
			let moves = movetext.split(/\s/)
			let color = BLACK
			for (let move of moves) {
				if (!move) continue
				color = 1 - color
				if (move === "0-0") {
					if (color === BLACK) move = "Ke8g8"
					else move = "Ke1g1"
				} else if (move === "0-0-0") {
					if (color === BLACK) move = "Ke8c8"
					else move = "Ke1c1"
				}
				const mo = move.match(/^(?<char>[B-R]?)(?<from>[a-h][1-8])x?(?<to>[a-h][1-8])(?<promo>[B-R]?)/)
				if (mo) {
					await show_move(mo.groups.from, mo.groups.to)
				}
			}
			black_ai_box.checked = bai
			white_ai_box.checked = wai
			speak.checked = spk
		}

		const board = new Board()
		board.reset()
		render(board)
		window.board = board
		start_clock(WHITE)
		if (white_ai_box.checked) ai_move(board, 0, WHITE)
	</script>
</body>

</html>