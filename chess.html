<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Chess by Cees Timmerman, 2022-12-28</title>
	<style>
		/* Doesn't work in console.
		@font-face {
			font-family: 'TrueMonospace';
			src: url('fonts/GnuUnifontFull-Pm9P.ttf');
		}
		*/
		* {
			--bgcolor: brown;
			--fgcolor: yellow;
			color: var(--fgcolor);
			background-color: var(--bgcolor);
			border-color: var(--fgcolor);
			font-size: 10mm;
		}

		#alertcontainer {
			margin: 0;
			left: 0;
			top: 0;
			width: 100%;
			height: 100%;
			position: fixed;
			overflow: auto;
			display: flex;
			flex-wrap: wrap;
			align-items: center;
			/* vertical */
			justify-content: center;
			/* horizontal */
			visibility: hidden;
			background-color: rgba(0, 0, 0, 0.5);
		}

		.alert {
			margin: auto;
			border: 1px solid var(--fgcolor);
			border-radius: 5px;
			box-shadow: 10px 10px 10px rgb(0 0 0 / 20%);
			min-width: 10em;
			padding: 1em;
			background-color: var(--bgcolor);
			font-size: 200%;
			text-align: center;
		}

		#boardtext {
			display: block;
			/*font-family: TrueMonospace;*/
			font-size: 0;
			/* Gets rid of newline spaces. */
			margin: 1em 0;
			position: relative;
			/* For relative position absolute children. */
			white-space: pre;
		}

		.w {
			background-color: lightgrey;
		}

		.b {
			background-color: darkgrey;
		}

		.wf {
			color: white;
		}

		.bf {
			color: black;
		}

		.square {
			height: 1em;
			width: 1em;
			display: inline-block;
			line-height: 1em;
			text-align: center;
			cursor: pointer;
		}

		.piece {
			background-color: transparent;
			height: 1em;
			line-height: 1em;
			width: 1em;
			text-align: center;
			display: block;
			pointer-events: none;
			position: absolute;
			transition: 0.4s;
		}

		.selected.w {
			background: radial-gradient(lightgray 30%, yellow);
		}

		.selected.b {
			background: radial-gradient(darkgray 30%, yellow);
		}

		.selected.w.nobg {
			background: lightgray;
		}

		.selected.b.nobg {
			background: darkgray;
		}

		label {
			font-size: 0.5em;
		}

		ol {
			list-style-position: inside;
		}
	</style>
</head>

<body>
	<div id="boardtext"></div>
	<input id="guides" type="checkbox" checked><label for="guides">Show potential moves</label>
	<input id="black_ai_box" type="checkbox"><label for="black_ai_box">Black AI</label>
	<input id="white_ai_box" type="checkbox"><label for="white_ai_box">White AI</label>
	<input id="speak_black" type="checkbox"><label for="speak_black">Speak black moves</label>
	<input id="speak_white" type="checkbox"><label for="speak_white">Speak white moves</label>
	<div id="logtext"></div>
	<div id="alertcontainer" onclick="if(event.target===this)this.style.visibility='hidden'"></div>
	<script type="module">
		"use strict"
		const WHITE = 0
		const BLACK = 1

		class Piece {
			name = "Piece"
			char = "P"
			value = 0
			dirs = []
			moved = false
			constructor(x, y, color) {
				this.x = x
				this.y = y
				this.color = color ? color : WHITE
			}

			copy(piece) {
				if (!piece) piece = this
				const copy = new piece.constructor(this.x, this.y, this.color)
				copy.moved = this.moved
				return copy
			}

			get_moves(board, depth) {
				const grid = board.grid
				const moves = []
				for (let dir of this.dirs) {
					let tx = this.x + dir[0]
					let ty = this.y + dir[1]
					while (1) {
						let piece = board.xy2p([tx, ty])
						//console.log("Found", piece?.color, piece?.name, "at", tx, ty, xy2fr(tx,ty))
						if (piece === ' ') moves.push([tx, ty])
						else if (piece && piece.color !== this.color) {
							moves.push([tx, ty])
							break
						}
						else break

						tx += dir[0]
						ty += dir[1]
					}
				}
				return moves
			}

			get_threats(board, depth) {
				const grid = board.grid
				const threats = []
				for (let row in grid) {
					for (let col in grid) {
						const piece = grid[row][col]
						if (piece == ' ' || piece.color === this.color) continue
						if (piece.get_moves(board, depth + 1).find(xy => xy[0] === this.x && xy[1] === this.y)) threats.push(piece)
					}
				}
				return threats
			}

			move(board, fr, do_log) {
				this.moved = true
				const ox = this.x
				const oy = this.y
				const capture = board.fr2p(fr)
				const move = this.char + xy2fr(ox, oy) + (capture === ' ' ? '' : 'x') + fr
				const xy = fr2xy(fr)
				board.grid[oy][ox] = ' '
				this.x = xy[0]
				this.y = xy[1]
				board.grid[this.y][this.x] = this
				if (do_log) {
					board.log_check(move, 1 - this.color)
					if (capture !== ' ') board.captured.push(capture)
				}
			}
		}

		class Rook extends Piece {
			name = "Rook"
			char = "R"
			value = 5
			dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]]
		}

		class Knight extends Piece {
			name = "Knight"
			char = "N"
			value = 3

			get_moves(board, depth) {
				let moves = []
				for (let dir of [[-2, -1], [-2, 1], [-1, -2], [1, -2], [2, -1], [2, 1], [1, 2], [-1, 2]]) {
					const tx = this.x + dir[0]
					const ty = this.y + dir[1]
					const piece = board.xy2p([tx, ty])
					if (piece === ' ' || (piece && piece.color !== this.color)) {
						moves.push([tx, ty])
					}
				}
				return moves
			}
		}

		class Bishop extends Piece {
			name = "Bishop"
			char = "B"
			value = 3
			dirs = [[-1, -1], [1, -1], [-1, 1], [1, 1]]
		}

		class Queen extends Piece {
			name = "Queen"
			char = "Q"
			value = 9
			dirs = [[-1, -1], [1, -1], [-1, 1], [1, 1], [1, 0], [-1, 0], [0, 1], [0, -1]]
		}

		class King extends Piece {
			name = "King"
			char = "K"
			value = 10  // Officially 0; playwise 3.5 to 4.

			get_moves(board, depth) {
				if (!depth) depth = 0
				if (depth > 1) return []
				const grid = board.grid
				const moves = []
				for (let dir of [[-1, -1], [1, -1], [-1, 1], [1, 1], [1, 0], [-1, 0], [0, 1], [0, -1]]) {
					let tx = this.x + dir[0]
					let ty = this.y + dir[1]
					let piece = board.xy2p([tx, ty])
					if (piece === ' ' || (piece && piece.color !== this.color)) {
						moves.push([tx, ty])
					}
				}
				// Castling.
				/* https://chessily.com/learn-chess/king/
				The king and rook have not yet been moved in the game.
				The king is not in check before and immediately after castling.
				The king will not move through a check during castling.
				All squares between the rook and king are empty.
				*/
				if (!this.moved && this.get_threats(board, depth).length === 0) {
					const rank = this.color ? 8 : 1
					let piece = board.fr2p('a' + rank)
					if (piece.char === 'R' && !piece.moved) {
						let clear = true
						for (let i = 1; i < this.x; ++i) {
							if (grid[8 - rank][i] !== ' ') clear = false
						}
						if (clear) moves.push([2, 8 - rank])
					}
					piece = board.fr2p('h' + rank)
					if (piece.char === 'R' && !piece.moved) {
						let clear = true
						for (let i = 6; i > this.x; --i) {
							if (grid[8 - rank][i] !== ' ') clear = false
						}
						if (clear) moves.push([6, 8 - rank])
					}
				}
				// Remove unsafe moves.
				let safe_moves = []
				for (let move of moves) {
					if (board.xy2p(move).char === "K") safe_moves.push(move)
					else {
						let new_board = board.copy()
						let new_piece = new_board.grid[this.y][this.x]
						let fr = xy2fr(...move)
						new_piece.move(new_board, fr)
						if (new_piece.get_threats(new_board, depth).length === 0) safe_moves.push(move)
					}
				}
				if (!this.moved) {
					// Can't castle over unsafe space.
					const frs = safe_moves.map(e => xy2fr(...e))
					for (let i = safe_moves.length - 1; i >= 0; --i) {
						let fr = xy2fr(...safe_moves[i])
						if (
							(fr === 'c8' && frs.indexOf('d8') < 0) ||
							(fr === 'g8' && frs.indexOf('f8') < 0) ||
							(fr === 'c1' && frs.indexOf('d1') < 0)
						) safe_moves.splice(i, 1)
					}
				}
				return safe_moves
			}

			move(board, fr, do_log) {
				super.move(board, fr, do_log)
				if (!do_log) return
				let move = board.log.pop()
				const y = this.y
				const rank = 8 - y
				if (move === `Ke${rank}g${rank}`) { // TODO? Only 5171 according to https://en.wikipedia.org/wiki/ICCF_numeric_notation
					move = '0-0'
					board.grid[y][7].move(board, 'f' + rank)
				}
				if (move === `Ke${rank}c${rank}`) {
					move = '0-0-0'
					board.grid[y][0].move(board, 'd' + rank)
				}
				board.log_check(move, 1 - this.color)
			}
		}

		class Pawn extends Piece {
			name = "Pawn"
			char = ""
			value = 1

			get_moves(board, depth) {
				const grid = board.grid
				const log = board.log
				const moves = []
				// Move straight.
				let dirs = this.color ? [[0, 1]] : [[0, -1]]
				for (let dir of dirs) {
					const tx = this.x + dir[0]
					const ty = this.y + dir[1]
					const piece = board.xy2p([tx, ty])
					if (piece === ' ') {
						moves.push([tx, ty])
						if (this.color && this.y === 1 && grid[ty + 1][tx] === ' ') moves.push([tx, ty + 1])
						if (!this.color && this.y === 6 && grid[ty - 1][tx] === ' ') moves.push([tx, ty - 1])
					}
				}
				// Capture diagonally.
				dirs = this.color ? [[-1, 1], [1, 1]] : [[-1, -1], [1, -1]]
				for (let dir of dirs) {
					const tx = this.x + dir[0]
					const ty = this.y + dir[1]
					const piece = board.xy2p([tx, ty])
					if ((piece && piece !== ' ' && piece.color !== this.color)) {
						moves.push([tx, ty])
					}
					// En passant.
					if ((this.color === BLACK && this.y === 4)
						|| (this.color === WHITE && this.y === 3)) {
						const double_jump = xy2fr(tx, this.color ? 6 : 1) + xy2fr(tx, this.color ? 4 : 3)
						if (log.slice(-1)[0] === double_jump) {
							moves.push([tx, ty])
						}
					}
				}
				return moves
			}

			move(board, fr, do_log) {
				super.move(board, fr, do_log)
				if (this.color === BLACK && this.y === 7
					|| this.color === WHITE && this.y === 0) {
					board.promote(fr, 'Q', this.color)
				}
				// En passant.
				if (this.color === BLACK && this.y != 5) return
				if (this.color === WHITE && this.y != 2) return
				const double_jump = xy2fr(this.x, this.color ? 6 : 1) + xy2fr(this.x, this.color ? 4 : 3)
				const log = board.log
				if (log.slice(-2)[0].slice(0, 4) === double_jump) {
					log[log.length - 1] += ' e.p.'
					board.grid[this.y + (this.color ? -1 : 1)][this.x] = ' '
				}
			}
		}

		class Board {
			grid = [[], [], [], [], [], [], [], []]
			log = []
			captured = []

			reset() {
				this.log = []
				this.grid = [
					[new Rook(0, 0, BLACK), new Knight(1, 0, BLACK), new Bishop(2, 0, BLACK), new Queen(3, 0, BLACK), new King(4, 0, BLACK), new Bishop(5, 0, BLACK), new Knight(6, 0, BLACK), new Rook(7, 0, BLACK)],
					[new Pawn(0, 1, BLACK), new Pawn(1, 1, BLACK), new Pawn(2, 1, BLACK), new Pawn(3, 1, BLACK), new Pawn(4, 1, BLACK), new Pawn(5, 1, BLACK), new Pawn(6, 1, BLACK), new Pawn(7, 1, BLACK)],
					[' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],
					[' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],
					[' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],
					[' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],
					[new Pawn(0, 6), new Pawn(1, 6), new Pawn(2, 6), new Pawn(3, 6), new Pawn(4, 6), new Pawn(5, 6), new Pawn(6, 6), new Pawn(7, 6)],
					[new Rook(0, 7), new Knight(1, 7), new Bishop(2, 7), new Queen(3, 7), new King(4, 7), new Bishop(5, 7), new Knight(6, 7), new Rook(7, 7)],
				]
			}

			get_king(color) {
				for (let row in this.grid) {
					for (let col in this.grid) {
						const piece = this.grid[row][col]
						if (piece.char === "K" && piece.color === color) return piece
					}
				}
			}

			get_pieces(color) {
				const rv = []
				for (let row in this.grid) {
					for (let col in this.grid) {
						const piece = this.grid[row][col]
						if (piece.color === color) rv.push(piece)
					}
				}
				return rv
			}

			is_check(color) {
				const king = this.get_king(color)
				return !!king && king.get_threats(this).length > 0
			}

			is_mate(color) {
				const king = this.get_king(color)
				if (!king) return false
				const saves = []
				for (let row in this.grid) {
					for (let col in this.grid) {
						let piece = this.grid[row][col]
						if (piece.color === color) {
							const moves = piece.get_moves(this)
							for (let move of moves) {
								const new_board = this.copy()
								const new_piece = new_board.grid[row][col]
								new_piece.move(new_board, xy2fr(...move))
								if (!new_board.is_check(color)) saves.push(new_piece.char + xy2fr(piece.x, piece.y) + xy2fr(...move))
							}
						}
					}
				}
				if (saves.length > 0) console.log("Save by", saves)
				return this.is_check(color) && king.get_moves(this).length === 0 && saves.length === 0
			}

			copy() {
				const new_board = new Board()
				new_board.log = [...this.log]
				new_board.captured = [...this.captured]
				for (let row in this.grid) {
					for (let col in this.grid) {
						const piece = this.grid[row][col]
						new_board.grid[row][col] = (piece === ' ') ? ' ' : piece.copy()
					}
				}
				return new_board
			}

			xy2p(xy) {
				if (xy[1] < 0 || xy[1] > 7 || xy[0] < 0 || xy[0] > 7) return ''
				return this.grid[xy[1]][xy[0]]
			}

			fr2p(fr) {
				const xy = fr2xy(fr)
				if (xy[0] >= 0 && xy[1] >= 0) return this.grid[xy[1]][xy[0]]
				return ''
			}

			log_check(move, color) {
				const c = this.is_check(color) ? (this.is_mate(color) ? '#' : '+') : ''
				this.log.push(move + c)
				if (c === '+') say('check')
				else if (c === '#') say('checkmate')
			}

			promote(fr, kind, color) {
				const [x, y] = fr2xy(fr)
				switch (kind) {
					case 'Q':
						this.grid[y][x] = new Queen(x, y, color)
						break
					case 'B':
						this.grid[y][x] = new Bishop(x, y, color)
						break
					case 'N':
						this.grid[y][x] = new Knight(x, y, color)
						break
					case 'R':
						this.grid[y][x] = new Rook(x, y, color)
						break
				}
			}
		}


		function xy2fr(x, y) {
			return "abcdefgh"[x] + (8 - y)
		}

		function fr2xy(fr) {
			return ["abcdefgh".indexOf(fr[0]), 8 - parseInt(fr[1])]
		}

		const icons = {
			'0': '♙', '1': '♟︎',
			'R0': '♖', 'R1': '♜',
			'N0': '♘', 'N1': '♞',
			'B0': '♗', 'B1': '♝',
			'Q0': '♕', 'Q1': '♛',
			'K0': '♔', 'K1': '♚',
		}

		function render(board) {
			const grid = board.grid
			const log = board.log

			let files = `<span class="square">` + (` abcdefgh`.split('').join('</span><span class="square">')) + `</span>`
			let lines = [files]
			for (let row in grid) {
				let line = `<span class="square">${8 - row}</span>`
				for (let col in grid) {
					line += `<span id="${xy2fr(col, row)}" class="square ${'wbw'[row % 2 + col % 2]}">  </span>`
				}
				line += `<span class="square">${8 - row}</span>`
				lines.push(line)
			}
			lines.push(files)

			files = ' abcdefgh'
			let blank = ' '
			if (navigator.userAgent.indexOf('Windows') > -1) {
				files = ' a b c d e f g h '
				blank = '  '
			}
			let text_lines = [files]
			for (let row in grid) {
				let text_line = `${8 - row}\x1B[30m`
				for (let col in grid) {
					text_line += ['\x1B[47m', '\x1B[100m', '\x1B[47m'][row % 2 + col % 2]
					const p = grid[row][col]
					if (p === ' ') {
						text_line += navigator.userAgent.indexOf('Windows') > -1 ? '  ' : ' '
						continue
					}
					// text_line += (p.color? '\x1B[30m' : '\x1B[97m') + icons[p.char + 1]  // Lacks contrast.
					text_line += icons[p.char + p.color]
					let html = ''
					if (p.color) html = `<span class="piece bf">${icons[p.char + '1']}</span>`
					else html = `<span class="piece wf">${icons[p.char + '1']}</span><span class="piece bf">${icons[p.char + '0']}</span>`
					lines.push(`<div id="p${xy2fr(col, row)}" class='piece' style='left: ${1 + parseInt(col)}em; top: ${1 + parseInt(row)}em'>${html}</div>`)
				}
				text_lines.push(text_line + `\x1B[m${8 - row}`)
			}
			text_lines.push(files)
			console.log(text_lines.join('\n'))
			boardtext.innerHTML = lines.join('\n')

			let html = ''
			let txt = ''
			for (let i = 0; i < log.length; i += 2) {
				html += `<li>${log[i]} ${log[i + 1] || ''}</li>`
				txt += `${1 + i / 2}. ${log[i]} ${log[i + 1] || ''} `
			}
			logtext.innerHTML = `<ol>${html}</ol>`

			console.log(board.captured.map(e => icons[e.char + e.color]).join(''))
			if (txt.length > 97) console.log(`...${txt.slice(-97)}`)
			else console.log(txt)

			document.querySelectorAll('.square').forEach(el => {
				el.onmousedown = function (e) {
					e.preventDefault()  // Stop doubleclick select.
				}
				el.onmouseup = function (e) {
					if (this.classList.contains('selected')) {
						if (start_fr && start_fr !== this.id) {
							show_move(start_fr, this.id, true)
							start_fr = null
							return
						}
					}
					document.querySelectorAll('.selected').forEach(el => {
						el.classList.remove('selected')
						el.classList.remove('nobg')
					})
					const piece = board.fr2p(this.id)
					if (!piece || piece === ' ' || this.id === window.start_fr) {
						window.start_fr = null
						return
					}
					window.start_fr = this.id
					this.classList.add('selected')
					const moves = piece.get_moves(board)
					for (let move of moves) {
						let square = document.getElementById(xy2fr(...move))
						square.classList.add('selected')
						if (!guides.checked) square.classList.add('nobg')
					}
				}
			})
		}

		function random_choice(array) {
			return array[Math.floor(Math.random() * array.length)]
		}

		async function ai_move(color) {
			const pieces = board.get_pieces(color)
			let moves = null
			let tries = 0
			while (++tries) {
				try {
					const piece = random_choice(pieces)
					const moves = piece.get_moves(board)
					if (moves.length > 0) {
						const move = random_choice(moves)
						await show_move(xy2fr(piece.x, piece.y), xy2fr(...move))
						return
					}
				} catch (ex) {
					if (tries > 1000) {
						console.log("Can't find a move.")
						break
					}
				}
			}
		}

		import sleep from './sleep.js'
		import say from './say.js'
		window.say = say

		async function show_move(start_fr, stop_fr, is_human) {
			const piece = board.fr2p(start_fr)
			const c = piece.char
			const color = piece.color
			// view
			const msg = `${["White", "Black"][piece.color]} ${piece.name} from ${start_fr} to ${stop_fr}.`
			console.log(msg)
			if ((color === BLACK && speak_black.checked) ||
				(color === WHITE && speak_white.checked)) say(msg.toUpperCase())  // fix 'a2'

			const style = document.getElementById('p' + start_fr).style
			const [x, y] = fr2xy(stop_fr)
			style.left = (1 + x) + 'em'
			style.top = (1 + y) + 'em'

			piece.move(board, stop_fr, true)
			await sleep(400).then(async () => {
				render(board)
				if (is_human && c === '' && (
					(color === BLACK && y === 7) ||
					(color === WHITE && y === 0))) {
					let html = `
						<button onclick="promote('${stop_fr}', 'Q', ${color})">♛</button>
						<button onclick="promote('${stop_fr}', 'B', ${color})">♝</button>
						<button onclick="promote('${stop_fr}', 'N', ${color})">♞</button>
						<button onclick="promote('${stop_fr}', 'R', ${color})">♜</button>
						`
					nonblocking_alert(html)
				}

				await sleep(4000).then(() => {
					if (color === WHITE && black_ai_box.checked) ai_move(BLACK)
					if (color === BLACK && white_ai_box.checked) ai_move(WHITE)
				})
			})
		}

		export default function promote(fr, kind, color) {
			board.promote(fr, kind, color)
			board.log_check(board.log.pop() + kind, 1 - color)
			render(board)
			alertcontainer.style.visibility = 'hidden'
		}
		window.promote = promote

		function nonblocking_alert(html) {
			if (getComputedStyle(alertcontainer).visibility == 'hidden') {
				alertcontainer.innerText = ''
				alertcontainer.style.visibility = 'visible'
			}
			const d = document.createElement('div')
			d.className = 'alert'
			d.innerHTML = html
			alertcontainer.appendChild(d)
		}

		const board = new Board()
		board.reset()
		render(board)
		window.board = board
		if (white_ai_box.checked) ai_move(WHITE)
	</script>
</body>

</html>