<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Chess by Cees Timmerman, 2022-12-28</title>
	<style>
		* {
			--bgcolor: brown;
			--fgcolor: yellow;
			color: var(--fgcolor);
			background-color: var(--bgcolor);
			font-size: 10mm;
		}

		#alertcontainer {
			margin: 0;
			left: 0;
			top: 0;
			width: 100%;
			height: 100%;
			position: fixed;
			overflow: auto;
			display: flex;
			flex-wrap: wrap;
			align-items: center;
			/* vertical */
			justify-content: center;
			/* horizontal */
			visibility: hidden;
			background-color: rgba(0, 0, 0, 0.5);
		}

		.alert {
			margin: auto;
			border: 1px solid var(--fgcolor);
			border-radius: 5px;
			box-shadow: 10px 10px 10px rgb(0 0 0 / 20%);
			min-width: 10em;
			padding: 1em;
			background-color: var(--bgcolor);
			font-size: 200%;
			text-align: center;
		}

		#boardtext {
			display: block;
			font-family: monospace;
			font-size: 0; // Gets rid of newline spaces.
			margin: 1em 0;
			white-space: pre;
		}

		.w {
			background-color: lightgrey;
		}

		.b {
			background-color: darkgrey;
		}

		.wf {
			color: white;
		}

		.bf {
			color: black;
		}

		.square {
			height: 1em;
			width: 1em;
			display: inline-block;
			line-height: 1em;
			text-align: center;
			cursor: pointer;
		}

		.piece {
			background-color: transparent;
			position: relative;
		}

		.over {
			margin-left: -1em;
		}

		.selected.w {
			background: radial-gradient(lightgray 30%, yellow);
		}

		.selected.b {
			background: radial-gradient(darkgray 30%, yellow);
		}

		.selected.w.nobg {
			background: lightgray;
		}

		.selected.b.nobg {
			background: darkgray;
		}

		label {
			font-size: 0.5em;
		}
	</style>
</head>

<body>
	<div id="boardtext"></div>
	<input id="guides" type="checkbox" checked><label for="guides">Show potential moves</label>
	<div id="logtext"></div>
	<div id="alertcontainer" onclick="if(event.target===this)this.style.visibility='hidden'"></div>
	<script>
		"use strict"
		const WHITE = 0
		const BLACK = 1

		class Piece {
			name = "Piece"
			char = "P"
			value = 0
			dirs = []
			moved = false
			constructor(x, y, color) {
				this.x = x
				this.y = y
				this.color = color ? color : WHITE
				this.html = this.color ? '<span class="piece bf">?</span>' : '<span class="piece bf over">?</span>'
			}

			copy() {
				return new Piece(this.x, this.y, this.color)
			}

			get_moves(board, depth) {
				let grid = board.grid
				let moves = []
				for (let dir of this.dirs) {
					let tx = this.x + dir[0]
					let ty = this.y + dir[1]
					while (1) {
						let piece = board.xy2p([tx, ty])
						//console.log("Found", piece?.color, piece?.name, "at", tx, ty, xy2fr(tx,ty))
						if (piece === ' ') moves.push([tx, ty])
						else if (piece && piece.color !== this.color) {
							moves.push([tx, ty])
							break
						}
						else break

						tx += dir[0]
						ty += dir[1]
					}
				}
				return moves
			}

			get_threats(board, depth) {
				let grid = board.grid
				let threats = []
				for (let row in grid) {
					for (let col in grid) {
						let piece = grid[row][col]
						if (piece == ' ' || piece.color === this.color) continue
						if (piece.get_moves(board, depth + 1).find(xy => xy[0] === this.x && xy[1] === this.y)) threats.push(piece)
					}
				}
				return threats
			}

			move(board, fr, do_log) {
				this.moved = true
				let xy = fr2xy(fr)
				if (do_log) board.log.push(this.char + xy2fr(this.x, this.y) + (board.fr2p(fr) === ' ' ? '' : 'x') + fr)
				board.grid[this.y][this.x] = ' '
				this.x = xy[0]
				this.y = xy[1]
				board.grid[this.y][this.x] = this
			}
		}

		class Rook extends Piece {
			name = "Rook"
			char = "R"
			value = 5
			dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]]
			constructor(x, y, color) {
				super(x, y, color)
				this.html = this.color ? '<span class="piece bf">♜</span>' : '<span class="piece wf">♜</span><span class="piece bf over">♖</span>'
			}

			copy() {
				return new Rook(this.x, this.y, this.color)
			}
		}

		class Knight extends Piece {
			name = "Knight"
			char = "N"
			value = 3
			constructor(x, y, color) {
				super(x, y, color)
				this.html = this.color ? '<span class="piece bf">♞</span>' : '<span class="piece wf">♞</span><span class="piece bf over">♘</span>'
			}

			copy() {
				return new Knight(this.x, this.y, this.color)
			}

			get_moves(board, depth) {
				let moves = []
				for (let dir of [[-2, -1], [-2, 1], [-1, -2], [1, -2], [2, -1], [2, 1], [1, 2], [-1, 2]]) {
					let tx = this.x + dir[0]
					let ty = this.y + dir[1]
					let piece = board.xy2p([tx, ty])
					if (piece === ' ' || (piece && piece.color !== this.color)) {
						moves.push([tx, ty])
					}
				}
				return moves
			}
		}

		class Bishop extends Piece {
			name = "Bishop"
			char = "B"
			value = 3
			dirs = [[-1, -1], [1, -1], [-1, 1], [1, 1]]
			constructor(x, y, color) {
				super(x, y, color)
				this.html = this.color ? '<span class="piece bf">♝</span>' : '<span class="piece wf">♝</span><span class="piece bf over">♗</span>'
			}

			copy() {
				return new Bishop(this.x, this.y, this.color)
			}
		}

		class Queen extends Piece {
			name = "Queen"
			char = "Q"
			value = 9
			dirs = [[-1, -1], [1, -1], [-1, 1], [1, 1], [1, 0], [-1, 0], [0, 1], [0, -1]]
			constructor(x, y, color) {
				super(x, y, color)
				this.html = this.color ? '<span class="piece bf">♛</span>' : '<span class="piece wf">♛</span><span class="piece bf over">♕</span>'
			}

			copy() {
				return new Queen(this.x, this.y, this.color)
			}
		}

		class King extends Piece {
			name = "King"
			char = "K"
			value = 10  // Officially 0; playwise 3.5 to 4.
			constructor(x, y, color) {
				super(x, y, color)
				this.html = this.color ? '<span class="piece bf">♚</span>' : '<span class="piece wf">♚</span><span class="piece bf over">♔</span>'
			}

			copy() {
				return new King(this.x, this.y, this.color)
			}

			get_moves(board, depth) {
				if (!depth) depth = 0
				if (depth > 1) return []
				let grid = board.grid
				let moves = []
				for (let dir of [[-1, -1], [1, -1], [-1, 1], [1, 1], [1, 0], [-1, 0], [0, 1], [0, -1]]) {
					let tx = this.x + dir[0]
					let ty = this.y + dir[1]
					let piece = board.xy2p([tx, ty])
					if (piece === ' ' || (piece && piece.color !== this.color)) {
						moves.push([tx, ty])
					}
				}
				// Castling.
				/* https://chessily.com/learn-chess/king/
				The king and rook have not yet been moved in the game.
				The king is not in check before and immediately after castling.
				TODO: The king will not move through a check during castling.
				All squares between the rook and king are empty.
				*/
				if (this.get_threats(board, depth).length === 0) {
					let rank = this.color ? 8 : 1
					if (!this.moved) {
						if (!board.fr2p('a' + rank).moved) {
							// Queenside: 0-0-0
							let clear = true
							for (let i = 1; i < this.x; ++i) {
								if (grid[8 - rank][i] !== ' ') clear = false
							}
							if (clear) moves.push([2, 8 - rank])
						}
						if (!board.fr2p('h' + rank).moved) {
							// Kingside: 0-0
							let clear = true
							for (let i = 6; i > this.x; --i) {
								if (grid[8 - rank][i] !== ' ') clear = false
							}
							if (clear) moves.push([6, 8 - rank])
						}
					}
				}
				// Remove unsafe moves.
				let safe_moves = []
				for (let move of moves) {
					let new_board = board.copy()
					console.log("New board:")
					//render(new_board)
					let new_piece = new_board.grid[this.y][this.x]
					console.log(depth, "Getting cloned piece at", this.x, this.y, ":", new_piece)
					let fr = xy2fr(...move)
					new_piece.move(new_board, fr)
					let threats = new_piece.get_threats(new_board, depth)
					console.log('K', fr, '=>', threats)
					if (threats.length === 0) safe_moves.push(move)
				}
				let frs = safe_moves.map(e => xy2fr(e))
				console.log("Safe moves", frs)
				return safe_moves
			}

			move(board, fr, do_log) {
				super.move(board, fr, do_log)
				let move = board.log[board.log.length - 1]
				let y = this.y
				let rank = 8 - y
				if (move === `Ke${rank}g${rank}`) { // TODO? Only 5171 according to https://en.wikipedia.org/wiki/ICCF_numeric_notation
					move = '0-0'
					board.grid[y][7].move(board, 'f' + rank)
				}
				if (move === `Ke${rank}c${rank}`) {
					move = '0-0-0'
					board.grid[y][0].move(board, 'd' + rank)
				}
				board.log[board.log.length - 1] = move
			}
		}

		class Pawn extends Piece {
			name = "Pawn"
			char = ""
			value = 1
			constructor(x, y, color) {
				super(x, y, color)
				this.html = this.color ? '<span class="piece bf">♟︎</span>' : '<span class="piece wf">♟︎</span><span class="piece bf over">♙</span>'
			}

			copy() {
				return new Pawn(this.x, this.y, this.color)
			}

			get_moves(board, depth) {
				let grid = board.grid
				let log = board.log
				let moves = []
				// Move straight.
				let dirs = this.color ? [[0, 1]] : [[0, -1]]
				for (let dir of dirs) {
					let tx = this.x + dir[0]
					let ty = this.y + dir[1]
					let piece = board.xy2p([tx, ty])
					if (piece === ' ') {
						moves.push([tx, ty])
						if (this.color && this.y === 1 && grid[ty + 1][tx] === ' ') moves.push([tx, ty + 1])
						if (!this.color && this.y === 6 && grid[ty - 1][tx] === ' ') moves.push([tx, ty - 1])
					}
				}
				// Capture diagonally.
				dirs = this.color ? [[-1, 1], [1, 1]] : [[-1, -1], [1, -1]]
				for (let dir of dirs) {
					let tx = this.x + dir[0]
					let ty = this.y + dir[1]
					let piece = board.xy2p([tx, ty])
					if ((piece && piece !== ' ' && piece.color !== this.color)) {
						moves.push([tx, ty])
					}
					// En passant.
					if ((this.color === BLACK && this.y === 4)
						|| (this.color === WHITE && this.y === 3)) {
						let double_jump = xy2fr(tx, this.color ? 6 : 1) + xy2fr(tx, this.color ? 4 : 3)
						if (log.slice(-1)[0] === double_jump) {
							moves.push([tx, ty])
						}
					}
				}
				return moves
			}

			move(board, fr, do_log) {
				super.move(board, fr, do_log)
				if (this.color === BLACK && this.y === 7
					|| this.color === WHITE && this.y === 0) {
					board.promote(fr, 'Q', this.color)
					let html = `
					<button onclick="board.promote('${fr}', 'Q', ${this.color}); render(board)">♛</button>
					<button onclick="board.promote('${fr}', 'B', ${this.color}); render(board)">♝</button>
					<button onclick="board.promote('${fr}', 'N', ${this.color}); render(board)">♞</button>
					<button onclick="board.promote('${fr}', 'R', ${this.color}); render(board)">♜</button>
					`
					nonblocking_alert(html)
				}
				// En passant.
				if (this.color === BLACK && this.y != 5) return
				if (this.color === WHITE && this.y != 2) return
				let double_jump = xy2fr(this.x, this.color ? 6 : 1) + xy2fr(this.x, this.color ? 4 : 3)
				let log = board.log
				if (log.slice(-2)[0] === double_jump) {
					log[log.length - 1] += ' e.p.'
					board.grid[this.y + (this.color ? -1 : 1)][this.x] = ' '
				}
			}
		}

		function xy2fr(x, y) {
			return "abcdefgh"[x] + (8 - y)
		}

		function fr2xy(fr) {
			return ["abcdefgh".indexOf(fr[0]), 8 - parseInt(fr[1])]
		}

		function render(board) {
			let grid = board.grid
			let log = board.log
			let files = `<span class="square">` + (` abcdefgh`.split('').join('</span><span class="square">')) + `</span>`
			let lines = [files]
			for (let row in grid) {
				let line = `<span class="square">${8 - row}</span>`
				for (let col in grid) {
					line += `<span id="${xy2fr(col, row)}" class="square ${'wbw'[row % 2 + col % 2]}">${grid[row][col].html || '  '}</span>`
				}
				line += `<span class="square">${8 - row}</span>`
				lines.push(line)
			}
			lines.push(files)
			logtext.innerHTML = '<ol><li>' + log.join('</li><li>') + '</li></ol>'
			boardtext.innerHTML = lines.join('\n')
			/*
			 a b c d e f g h 
			8♜♞♝♛♚♝♞♜8
			7♟︎♟︎♟︎♟︎♟︎♟︎♟︎♟︎7
			6                6
			5                5
			4                4
			3                3
			2♟︎♙♟︎♙♟︎♙♟︎♙♟︎♙♟︎♙♟︎♙♟︎♙2
			1♜♖♞♘♝♗♛♕♚♔♝♗♞♘♜♖1
			 a b c d e f g h 
			*/
			let s = boardtext.innerText.replaceAll(/([a-z])([a-z])/g, '$1 $2 ')
			for (let pair of [['♟︎♙', '♙'], ['♜♖', '♖'], ['♞♘', '♘'], ['♝♗', '♗'], ['♛♕', '♕'], ['♚♔', '♔']]) s = s.replaceAll(new RegExp(pair[0], 'g'), pair[1])
			console.log(s)
			console.log(log)
			document.querySelectorAll('.square').forEach(el => {
				//console.log(e)
				el.onmousedown = function (e) {
					e.preventDefault()  // Stop doubleclick select.
				}
				el.onmouseup = function (e) {
					if (this.classList.contains('selected')) {
						let piece = window.selected_piece
						if (this.id !== xy2fr(piece.x, piece.y)) {
							piece.move(board, this.id, true)
							render(board)
						}
						return
					}
					let piece = board.fr2p(this.id)
					if (!piece || piece === ' ') return
					window.selected_piece = piece
					console.log("Selected", piece.color, piece.name, "at", this.id)
					document.querySelectorAll('.selected').forEach(el => {
						el.classList.remove('selected')
						el.classList.remove('nobg')
					})
					this.classList.add('selected')
					let moves = piece.get_moves(board)
					console.log("Moves", moves)
					for (let move of moves) {
						let square = document.getElementById(xy2fr(...move))
						square.classList.add('selected')
						if (!guides.checked) square.classList.add('nobg')
					}
				}
			})
		}

		function nonblocking_alert(html) {
			if (getComputedStyle(alertcontainer).visibility == 'hidden') {
				alertcontainer.innerText = ''
				alertcontainer.style.visibility = 'visible'
			}
			const d = document.createElement('div')
			d.className = 'alert'
			d.innerHTML = html
			alertcontainer.appendChild(d)
		}

		class Board {
			log = []
			grid = [[],[],[],[],[],[],[],[]]

			reset() {
				this.log = []
				this.grid = [
					[new Rook(0, 0, BLACK), new Knight(1, 0, BLACK), new Bishop(2, 0, BLACK), new Queen(3, 0, BLACK), new King(4, 0, BLACK), new Bishop(5, 0, BLACK), new Knight(6, 0, BLACK), new Rook(7, 0, BLACK)],
					[new Pawn(0, 1, BLACK), new Pawn(1, 1, BLACK), new Pawn(2, 1, BLACK), new Pawn(3, 1, BLACK), new Pawn(4, 1, BLACK), new Pawn(5, 1, BLACK), new Pawn(6, 1, BLACK), new Pawn(7, 1, BLACK)],
					[' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],
					[' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],
					[' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],
					[' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],
					[new Pawn(0, 6), new Pawn(1, 6), new Pawn(2, 6), new Pawn(3, 6), new Pawn(4, 6), new Pawn(5, 6), new Pawn(6, 6), new Pawn(7, 6)],
					[new Rook(0, 7), new Knight(1, 7), new Bishop(2, 7), new Queen(3, 7), new King(4, 7), new Bishop(5, 7), new Knight(6, 7), new Rook(7, 7)],
				]
			}

			copy() {
				let new_board = new Board()
				new_board.log = [...this.log]
				for (let row in this.grid) {
					for (let col in this.grid) {
						let piece = this.grid[row][col]
						new_board.grid[row][col] = (piece === ' ') ? ' ' : piece.copy()
					}
				}
				return new_board
			}

			xy2p(xy) {
				if (xy[1] < 0 || xy[1] > 7 || xy[0] < 0 || xy[0] > 7) return ''
				return this.grid[xy[1]][xy[0]]
			}

			fr2p(fr) {
				const xy = fr2xy(fr)
				if (xy[0] >= 0 && xy[1] >= 0) return this.grid[xy[1]][xy[0]]
				return ''
			}

			promote(fr, kind, color) {
				let [x, y] = fr2xy(fr)
				switch (kind) {
					case 'Q':
						grid[y][x] = new Queen(x, y, color)
						break
					case 'B':
						grid[y][x] = new Bishop(x, y, color)
						break
					case 'N':
						grid[y][x] = new Knight(x, y, color)
						break
					case 'R':
						grid[y][x] = new Rook(x, y, color)
						break
				}
			}
		}

		let board = new Board()
		board.reset()
		render(board)
	</script>
</body>

</html>